<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最长上升子序列</title>
      <link href="/2023/12/31/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2023/12/31/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="Ac895-动态规划"><a href="#Ac895-动态规划" class="headerlink" title="Ac895(动态规划)"></a>Ac895(动态规划)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;  <span class="comment">// 多开几个数据，防止数组下标越界</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  <span class="comment">// 输入数据个数</span></span><br><span class="line"><span class="type">int</span> a[N], f[N];  <span class="comment">// a存储读入的数据，f是动态规划数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;  <span class="comment">// 最长上升子序列结尾位置不一定是数组的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ac896-二分优化"><a href="#Ac896-二分优化" class="headerlink" title="Ac896(二分优化)"></a>Ac896(二分优化)</h4><ul><li>本题和上一题唯一的区别就是输入数组的大小增大了100倍，从最多1000个数据变成了最多100000个数据，如果还采用上述方法，则会TLE（超时），需要采用另外一种做法。</li><li>我们使用一个数组q来记录额外的信息，从前向后考察输入的数据（存储在a数组中），用q[t]记录考察到当前元素是<strong>长度为t的上升子序列结尾的最小值</strong>，则根据定义可以推出 q 是一个严格单调上升的子序列，这可以用反证法进行证明。如下图：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || a[i] &gt; f[j])</span><br><span class="line">            f[++ j] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *<span class="built_in">lower_bound</span>(f + <span class="number">1</span>, f + <span class="number">1</span> + j, a[i]) = a[i];</span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nc91（动态规划记录方案）"><a href="#Nc91（动态规划记录方案）" class="headerlink" title="Nc91（动态规划记录方案）"></a>Nc91（动态规划记录方案）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>(), len = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) </span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);         </span><br><span class="line">            len = <span class="built_in">max</span>(len, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>, j = len; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span>(f[i] == j)</span><br><span class="line">                res[-- j] = a[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Nc91（二分优化记录方案）"><a href="#Nc91（二分优化记录方案）" class="headerlink" title="Nc91（二分优化记录方案）"></a>Nc91（二分优化记录方案）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>(), len = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span>, q</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">empty</span>() || a[i] &gt; q.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                f[i] = q.<span class="built_in">size</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), a[i]) - q.<span class="built_in">begin</span>();</span><br><span class="line">                q[pos] = a[i];</span><br><span class="line">                f[i] = pos + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="built_in">max</span>(len, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>, j = len; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span>(f[i] == j)</span><br><span class="line">                res[-- j] = a[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拦截器</title>
      <link href="/2023/12/16/%E9%9D%A2%E8%AF%95/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2023/12/16/%E9%9D%A2%E8%AF%95/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="web开发中的拦截器"><a href="#web开发中的拦截器" class="headerlink" title="web开发中的拦截器"></a>web开发中的拦截器</h5><p>在Web开发中，拦截器（Interceptor）是一种常见的设计模式，用于在请求处理的不同阶段插入自定义的代码逻辑。拦截器允许开发人员在请求到达目标处理程序之前或之后执行额外的逻辑。在不同的Web框架和技术中，拦截器可能有不同的名称，如中间件、过滤器等。</p><p>以下是拦截器在Web开发中的一般概念：</p><ol><li><p><strong>定义位置：</strong> 拦截器通常与请求处理框架结合使用，可以在请求的不同阶段插入自定义逻辑。这些阶段可能包括请求处理之前、请求处理之后、视图渲染之前等。</p></li><li><p><strong>功能：</strong> 拦截器的功能多种多样，包括但不限于：</p><ul><li><strong>身份验证和授权：</strong> 检查用户是否已登录，是否有权限访问特定资源。</li><li><strong>日志记录：</strong> 记录请求和响应的信息，用于调试和性能分析。</li><li><strong>异常处理：</strong> 在请求处理中捕获异常并进行适当的处理。</li><li><strong>数据转换：</strong> 修改请求或响应的数据格式或内容。</li><li><strong>缓存：</strong> 在请求处理之前检查是否存在缓存的响应，以提高性能。</li></ul></li><li><p><strong>执行顺序：</strong> 拦截器通常按照特定的顺序执行。这可以是预定义的顺序，也可以是根据配置动态确定的顺序。</p></li><li><p><strong>生命周期：</strong> 拦截器可能有自己的生命周期，可以在应用启动时初始化，也可以根据需要动态添加或移除。</p></li><li><p><strong>上下文对象：</strong> 拦截器通常可以访问请求和响应的上下文对象，以便获取有关请求和响应的详细信息。</p></li></ol><p>在具体的Web框架中，拦截器的实现方式可能有所不同。例如，在Java的Spring框架中，拦截器是通过实现<code>HandlerInterceptor</code>接口来定义的。在Node.js的Express框架中，中间件充当了拦截器的角色。在Django框架中，可以使用中间件来实现类似的功能。</p><p>总的来说，拦截器是一种强大的工具，可以帮助开发人员实现各种与请求处理相关的功能，并且可以提高代码的模块化和可维护性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>threadlocal</title>
      <link href="/2023/12/16/%E9%9D%A2%E8%AF%95/threadlocal/"/>
      <url>/2023/12/16/%E9%9D%A2%E8%AF%95/threadlocal/</url>
      
        <content type="html"><![CDATA[<h5 id="介绍一下threadlocal"><a href="#介绍一下threadlocal" class="headerlink" title="介绍一下threadlocal"></a>介绍一下threadlocal</h5><p>ThreadLocal是Java中的一个线程本地变量工具类，它提供了一种线程私有的变量存储方式。每个线程都可以通过ThreadLocal存储自己的变量副本，这样可以避免线程间的数据共享和竞争条件。</p><p>ThreadLocal通常被用来解决多线程并发访问共享变量的问题，它可以让每个线程都拥有自己的变量副本，从而避免了对共享变量的竞争，提高了程序的并发性能。</p><p>使用ThreadLocal可以在多线程环境下方便地实现数据的隔离和线程安全，例如在Web开发中，可以将用户信息存储在ThreadLocal中，以便在整个请求处理过程中方便地访问和操作。</p><p>总的来说，ThreadLocal提供了一种简单而有效的方式来管理线程私有的变量，可以避免多线程并发访问共享变量时可能引发的问题，是Java中非常重要的并发编程工具之一。</p><h5 id="为什么在web开发的时候，要将用户的信息存储在ThreadLocal中"><a href="#为什么在web开发的时候，要将用户的信息存储在ThreadLocal中" class="headerlink" title="为什么在web开发的时候，要将用户的信息存储在ThreadLocal中"></a>为什么在web开发的时候，要将用户的信息存储在ThreadLocal中</h5><p>在Web开发中，将用户信息存储在ThreadLocal中的一个常见的用途是为了在整个请求处理过程中方便地访问和操作用户信息，而不需要在每个方法中传递用户信息参数或者从全局变量中获取用户信息。</p><p>当一个用户发送请求到服务器时，服务器通常会创建一个线程来处理该请求。在处理请求的过程中，可能会有多个方法需要访问用户信息，例如验证用户身份、记录日志、权限控制等。如果每个方法都需要从参数或者全局变量中获取用户信息，会显得非常繁琐和容易出错。</p><p>通过将用户信息存储在ThreadLocal中，可以在请求处理过程中方便地访问和操作用户信息，而不需要在每个方法中传递用户信息参数或者从全局变量中获取用户信息。这样可以提高代码的可读性和可维护性，并且可以避免由于并发访问共享变量而可能引发的线程安全问题。</p><p>因此，在Web开发中，将用户信息存储在ThreadLocal中可以方便地实现数据的隔离和线程安全，提高了程序的并发性能，是一种常见的做法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>交换两个变量</title>
      <link href="/2023/12/14/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2023/12/14/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在不使用第三个变量的情况下，你可以使用算术运算或位运算来交换两个变量的值。以下是两种常见的方法：</p><h3 id="方法1-算术运算"><a href="#方法1-算术运算" class="headerlink" title="方法1: 算术运算"></a>方法1: 算术运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换后的值：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b)</span><br></pre></td></tr></table></figure><h3 id="方法2-位运算"><a href="#方法2-位运算" class="headerlink" title="方法2: 位运算"></a>方法2: 位运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换后的值：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b)</span><br></pre></td></tr></table></figure><p>这两种方法都可以在不使用第三个变量的情况下交换两个变量的值。请注意，这些方法可能在某些特定情况下效率更高，但在一般情况下，使用第三个变量来进行交换更容易理解和维护。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中重写优先队列的第三个参数</title>
      <link href="/2023/12/13/c++%E4%B8%AD%E9%87%8D%E5%86%99%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/2023/12/13/c++%E4%B8%AD%E9%87%8D%E5%86%99%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在C++中，优先队列是使用模板类实现的，其中第三个参数通常是比较函数（默认是std::less），用于定义元素的比较规则。如果需要重写优先队列中的第三个参数，可以通过自定义比较函数来实现。</p><p>首先，需要定义一个自定义的比较函数，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomCompare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义比较规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，在创建优先队列时，可以指定自定义的比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;T, std::vector&lt;T&gt;, CustomCompare&gt; pq;</span><br></pre></td></tr></table></figure><p>这样就可以使用自定义的比较函数来重写优先队列中的第三个参数。</p><h5 id="为什么自定义的比较函数要写在结构体里面？"><a href="#为什么自定义的比较函数要写在结构体里面？" class="headerlink" title="为什么自定义的比较函数要写在结构体里面？"></a>为什么自定义的比较函数要写在结构体里面？</h5><p>实际上，在C++中，自定义的比较函数不一定要写在结构体里面。自定义的比较函数可以写在结构体、类或者普通的函数对象中。</p><p>下面是一个示例，展示了如何定义一个自定义的比较函数，不使用结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自定义的比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">customCompare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义比较规则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在创建优先队列时，指定自定义的比较函数</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(&amp;customCompare)&gt; <span class="built_in">pq</span>(&amp;customCompare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，自定义的比较函数<code> customCompare</code>并没有写在结构体里面，而是直接作为一个普通的函数。然后在创建优先队列时，使用<code>decltype</code>来获取函数指针的类型，并将自定义的比较函数传递给优先队列的构造函数。</p><p>因此，自定义的比较函数可以以不同的方式实现，不一定要写在结构体里面。</p><h5 id="自定义的比较函数可以写在结构体、类或者普通的函数对象中。请分别介绍一下这几种方式"><a href="#自定义的比较函数可以写在结构体、类或者普通的函数对象中。请分别介绍一下这几种方式" class="headerlink" title="自定义的比较函数可以写在结构体、类或者普通的函数对象中。请分别介绍一下这几种方式"></a>自定义的比较函数可以写在结构体、类或者普通的函数对象中。请分别介绍一下这几种方式</h5><p>当需要自定义比较函数时，可以使用结构体、类或者普通的函数对象来实现。下面分别介绍这三种方式：</p><ol><li><p>结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomCompare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义比较规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式使用了函数调用运算符重载，使得结构体对象可以像函数一样被调用。在创建优先队列时，可以将该结构体作为第三个参数传入。</p></li><li><p>类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义比较规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式与结构体类似，也是通过重载函数调用运算符来实现自定义的比较函数。同样，在创建优先队列时，可以将该类作为第三个参数传入。</p></li><li><p>普通的函数对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">customCompare</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义比较规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式是定义一个普通的函数，不需要使用结构体或类。在创建优先队列时，可以将该函数名作为第三个参数传入。</p></li></ol><p>以上三种方式都可以用于自定义比较函数，具体选择取决于个人偏好和需求。在实际应用中，通常会选择最简洁和清晰的方式来实现自定义的比较函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie、Session、Token</title>
      <link href="/2023/12/11/cookie,session,token/"/>
      <url>/2023/12/11/cookie,session,token/</url>
      
        <content type="html"><![CDATA[<p>Cookie、Session、Token 是用于在 Web 开发中管理用户身份和状态的三种常见机制。</p><ol><li><p><strong>Cookie（HTTP Cookie）:</strong></p><ul><li><strong>定义：</strong> Cookie 是服务器发送到用户浏览器并保存在本地的小数据片段。它包含有关用户及其与网站的交互信息。</li><li><strong>工作原理：</strong> 当用户首次访问网站时，服务器可能会在响应头中包含 Set-Cookie 字段，其中包含了要在用户端存储的信息。浏览器收到这个响应后，将 Cookie 存储在本地。在之后的每次请求中，浏览器都会自动将相关的 Cookie 信息附加到请求头中发送给服务器。</li><li><strong>用途：</strong> 主要用于跟踪用户的会话信息、记住用户的偏好设置，以及进行身份验证等。</li></ul></li><li><p><strong>Session:</strong></p><ul><li><strong>定义：</strong> Session 是一种在服务器端存储用户信息的机制。服务器在用户首次访问时创建一个唯一的会话标识符（Session ID），并将该标识符存储在 Cookie 中或通过 URL 传递给客户端。</li><li><strong>工作原理：</strong> 当用户访问网站时，服务器根据请求中的 Session ID 查找对应的会话信息。会话信息通常存储在服务器的内存或数据库中，并与用户关联。</li><li><strong>用途：</strong> 主要用于在用户访问同一网站的不同页面时保持用户的状态，如登录状态、购物车内容等。</li></ul></li><li><p><strong>Token:</strong></p><ul><li><strong>定义：</strong> Token 是一种用于进行身份验证和授权的令牌。在 Web 开发中，常见的有 JSON Web Token (JWT)。</li><li><strong>工作原理：</strong> 用户在登录时，服务器生成一个包含用户身份信息的 Token，并将其发送给客户端。客户端在后续的请求中通过将 Token 放置在请求头中来进行身份验证。服务器通过验证 Token 来确认用户的身份。</li><li><strong>用途：</strong> 主要用于无状态的身份验证，允许用户在不同的请求之间保持状态，而无需在服务器端存储用户信息。常用于构建分布式系统和单点登录系统。</li></ul></li></ol><p>总体而言，这三种机制都是用来管理用户身份和状态的，但它们的实现方式和用途略有不同。Cookie 是在客户端存储的小段数据，Session 是在服务器端存储的用户信息，而 Token 是一种用于进行身份验证和授权的令牌。在实际开发中，可以根据具体需求选择合适的机制或将它们结合使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>康托展开与逆康托展开</title>
      <link href="/2023/11/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E4%B8%8E%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2023/11/16/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E4%B8%8E%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h4 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h4><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = a[n] * (n-1)! + a[n-1] * (n-2)! + …… + a[i] * (i-1)! + …… + a[2] * 1! + a[1] * 0!</span><br></pre></td></tr></table></figure><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> factorial[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>,<span class="number">3628800</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cantor</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">                sum++;</span><br><span class="line">        ans+=sum*factorial[n-i];</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sb[<span class="number">12</span>],gs;</span><br><span class="line">    cin&gt;&gt;gs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=gs;i++)</span><br><span class="line">        cin&gt;&gt;sb[i];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">cantor</span>(sb,gs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="逆康托展开代码实现"><a href="#逆康托展开代码实现" class="headerlink" title="逆康托展开代码实现"></a>逆康托展开代码实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static const int FAC[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;   // ??</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; decantor(int n, int x)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v; </span><br><span class="line">    vector&lt;int&gt; a;  </span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    for(int i=n;i&gt;=1;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        int r = x % FAC[i-1];</span><br><span class="line">        int t = x / FAC[i-1];</span><br><span class="line">        x = r;</span><br><span class="line">        //sort(v.begin(),v.end());</span><br><span class="line">        a.push_back(v[t]);     </span><br><span class="line">        v.erase(v.begin()+t);   </span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">vector&lt;int&gt; res = decantor(4, 9 - 1);</span><br><span class="line">for(auto&amp; c : res)</span><br><span class="line">cout &lt;&lt; c &lt;&lt; &#x27; &#x27;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中创建类</title>
      <link href="/2023/11/14/c++%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB/"/>
      <url>/2023/11/14/c++%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在这里，两种方式创建类的区别在于对象的生命周期和内存管理。</p><ol><li><p><code>Solution* s = new Solution;</code>这种方式创建了一个<code>Solution</code>类的指钽，并将其分配在堆上。这意味着对象的生命周期取决于<code>delete</code>操作，需要手动释放内存。这种方式适用于需要在程序的不同部分共享对象或者需要动态分配内存的情况。</p></li><li><p><code>Solution s;</code>这种方式创建了一个<code>Solution</code>类的对象，该对象被分配在栈上，其生命周期与其所在的作用域相关。当超出作用域时，对象会自动被销毁。这种方式适用于大多数情况，因为它更简单、更安全，不需要手动管理内存。</p></li></ol><p>在这个特定的情况下，应该使用<code>Solution s;</code>方式创建对象，因为不需要动态分配内存，而且对象的生命周期与其所在的作用域相关。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>师兄华子手撕题目</title>
      <link href="/2023/11/01/%E5%B8%88%E5%85%84%E5%8D%8E%E5%AD%90%E6%89%8B%E6%92%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2023/11/01/%E5%B8%88%E5%85%84%E5%8D%8E%E5%AD%90%E6%89%8B%E6%92%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="leetcode349两个数组的交集（结果保持字典序）"><a href="#leetcode349两个数组的交集（结果保持字典序）" class="headerlink" title="leetcode349两个数组的交集（结果保持字典序）"></a>leetcode349两个数组的交集（结果保持字典序）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">sort(nums1.begin(), nums1.end());</span><br><span class="line">sort(nums2.begin(), nums2.end());</span><br><span class="line"></span><br><span class="line">nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end());</span><br><span class="line">nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end());</span><br><span class="line"></span><br><span class="line">int m = nums1.size(), n = nums2.size();</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">for(int i = 0, j = 0, k = 0; i &lt; m &amp;&amp; j &lt; n; ) &#123;</span><br><span class="line">if(nums1[i] == nums2[j]) &#123;</span><br><span class="line">res.push_back(nums1[i ++]) , j ++;</span><br><span class="line">&#125; else if(nums1[i] &lt; nums2[j]) i ++ ;</span><br><span class="line">else j ++;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">unordered_set&lt;int&gt; h;</span><br><span class="line">for(auto c : nums1) h.insert(c);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">for(auto c : nums2)</span><br><span class="line">if(h.count(c))&#123;</span><br><span class="line">res.push_back(c);</span><br><span class="line">h.erase(c);</span><br><span class="line">&#125;</span><br><span class="line">sort(res.begin(), res.end());</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="给定一亿个正整数，如何实现一个算法挑出最大的十个数"><a href="#给定一亿个正整数，如何实现一个算法挑出最大的十个数" class="headerlink" title="给定一亿个正整数，如何实现一个算法挑出最大的十个数"></a>给定一亿个正整数，如何实现一个算法挑出最大的十个数</h5><p><code>1亿个int约等于380MB</code></p><p>下面是gpt的回答，给出了简单的思路</p><p>处理海量数据找出最大的10个数的问题通常需要一些高效的算法和数据结构，因为一次性将这么大的数据加载到内存中并排序可能不可行。以下是一种基于分而治之思想的常见解决方案：</p><ol><li><p><strong>分割阶段：</strong> 将10亿个数分割成多个小块，每个小块的数据规模适合加载到内存中。例如，将数据分成1000个小块，每个小块包含100万个数。</p></li><li><p><strong>局部求解：</strong> 对每个小块使用内存中的排序算法（例如，堆排序、快速排序等）找出该块中最大的10个数。</p></li><li><p><strong>全局合并：</strong> 将每个小块中的最大数维护在一个全局的优先队列（例如，最小堆）中。这样，我们可以在这个全局队列中保持当前找到的最大的10个数。</p></li><li><p><strong>最终整理：</strong> 当所有小块都处理完毕后，全局队列中的元素即为最大的10个数。</p></li></ol><p>这种方法的关键在于将大任务拆解成可管理的小任务，并且能够在内存中处理这些小任务。由于每个小块的数据规模较小，可以使用内存中的排序算法高效地找到局部最大的数，而全局最大的数则通过维护一个全局队列来得到。</p><p>这种方法的时间复杂度主要取决于排序每个小块的时间和合并全局队列的时间。这样的算法可以有效地处理大规模数据，因为它并不要求一次性加载所有数据到内存中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++如何写随机数骗分</title>
      <link href="/2023/11/01/c++%E5%A6%82%E4%BD%95%E5%86%99%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%AA%97%E5%88%86/"/>
      <url>/2023/11/01/c++%E5%A6%82%E4%BD%95%E5%86%99%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%AA%97%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>比如题目让我们输出”Yes”或者”No”，那这个时候就可以用随机数，根据随机数是奇数还是偶数来生成是或者否。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 设置随机种子</span><br><span class="line">    srand(time(nullptr));</span><br><span class="line"></span><br><span class="line">    // 生成随机数</span><br><span class="line">    int randomNum = rand() % 2;</span><br><span class="line"></span><br><span class="line">    // 根据随机数输出&quot;Yes&quot;或&quot;No&quot;</span><br><span class="line">    if (randomNum == 0) </span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如题目要我们输出0,1,2中的一个，则可以用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 设置随机种子</span><br><span class="line">    srand(time(nullptr));</span><br><span class="line"></span><br><span class="line">    // 生成随机数</span><br><span class="line">    int randomNum = rand() % 3;</span><br><span class="line"></span><br><span class="line">    // 输出随机数</span><br><span class="line">    cout &lt;&lt; randomNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图论算法</title>
      <link href="/2023/10/31/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/31/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h5 id="Dijkstra求最短路-I"><a href="#Dijkstra求最短路-I" class="headerlink" title="Dijkstra求最短路 I"></a>Dijkstra求最短路 I</h5><h6 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h6><p>Dijkstra的算法基于广度优先搜索，它利用了一个重要的事实：一个节点的最短路径不会包含一个比自己更远的节点。因此，我们可以从源节点开始，逐步“扩展”到所有可达的节点，直到找到目标节点为止。</p><h6 id="时间复杂是-O-n-2-m-n表示点数-m表示边数"><a href="#时间复杂是-O-n-2-m-n表示点数-m表示边数" class="headerlink" title="时间复杂是 O($n^2$+m) n表示点数,m表示边数"></a>时间复杂是 O($n^2$+m) n表示点数,m表示边数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int g[N][N];  // 存储每条边</span><br><span class="line">int dist[N];  // 存储1号点到每个点的最短距离</span><br><span class="line">bool st[N];   // 存储每个点的最短路是否已经确定</span><br><span class="line"></span><br><span class="line">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="line">int dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);</span><br><span class="line">    dist[1] = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n - 1; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点</span><br><span class="line">        for (int j = 1; j &lt;= n; j ++ )</span><br><span class="line">            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        // 用t更新其他点的距离</span><br><span class="line">        for (int j = 1; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dist[n] == 0x3f3f3f3f) return -1;</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Dijkstra算法不能处理存在负权边的图。如果图中存在负权重的边，可以考虑使用Bellman-Ford算法。</p><p>为了提高算法的效率，经常使用优先队列来选出tentative distance最小的节点。这样的话，Dijkstra算法的时间复杂度是O((V+E)logV)，其中V是顶点数，E是边数。</p><h5 id="Dijkstra求最短路-II-堆优化版dijkstra"><a href="#Dijkstra求最短路-II-堆优化版dijkstra" class="headerlink" title="Dijkstra求最短路 II (堆优化版dijkstra)"></a>Dijkstra求最短路 II (堆优化版dijkstra)</h5><h6 id="时间复杂度-O-m-log-n-n表示点，m表示边"><a href="#时间复杂度-O-m-log-n-n表示点，m表示边" class="headerlink" title="时间复杂度 O($m*\log_{n}{} $) n表示点，m表示边"></a>时间复杂度 O($m*\log_{n}{} $) n表示点，m表示边</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">int n;      // 点的数量</span><br><span class="line">int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边</span><br><span class="line">int dist[N];        // 存储所有点到1号点的距离</span><br><span class="line">bool st[N];     // 存储每个点的最短距离是否已确定</span><br><span class="line"></span><br><span class="line">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="line">int dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);</span><br><span class="line">    dist[1] = 0;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;0, 1&#125;);      // first存储距离，second存储节点编号</span><br><span class="line"></span><br><span class="line">    while (heap.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line"></span><br><span class="line">        int ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        if (st[ver]) continue;</span><br><span class="line">        st[ver] = true;</span><br><span class="line"></span><br><span class="line">        for (int i = h[ver]; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j = e[i];</span><br><span class="line">            if (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dist[n] == 0x3f3f3f3f) return -1;</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器输入网址到页面渲染全过程</title>
      <link href="/2023/10/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/10/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>当你在浏览器中输入你的博客域名并按下回车键时，会发生一系列复杂的过程，最终导致页面在浏览器中渲染出来。以下是整个过程的简要概述：</p><h3 id="1-DNS查询"><a href="#1-DNS查询" class="headerlink" title="1. DNS查询"></a>1. DNS查询</h3><ul><li><strong>域名解析</strong>：浏览器首先需要找到与你输入的域名相对应的服务器的IP地址。这是通过查询域名系统（DNS）来完成的。</li><li><strong>查询过程</strong>：浏览器检查它的缓存（如果有最近对该域名的查询）。如果缓存中没有，它会向本地DNS服务器发送查询请求。如果本地DNS服务器也没有答案，它会进一步向上游DNS服务器查询，直到找到正确的IP地址。</li></ul><h3 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h3><ul><li><strong>TCP连接</strong>：一旦获得IP地址，浏览器将尝试与服务器建立TCP连接。这通常涉及到三次握手过程。</li><li><strong>HTTPS握手</strong>：如果是HTTPS（推荐），还会有一个TLS握手过程，以确保通信的安全性。</li></ul><h3 id="3-发送HTTP请求"><a href="#3-发送HTTP请求" class="headerlink" title="3. 发送HTTP请求"></a>3. 发送HTTP请求</h3><ul><li><strong>构造请求</strong>：浏览器构建一个HTTP（或HTTPS）请求，并将其发送到服务器。这个请求包含了你想要访问的页面的路径，以及一些其他的头信息（如浏览器类型、接受的语言等）。</li></ul><h3 id="4-服务器处理请求"><a href="#4-服务器处理请求" class="headerlink" title="4. 服务器处理请求"></a>4. 服务器处理请求</h3><ul><li><strong>接收请求</strong>：服务器接收到请求，并根据请求的路径查找相应的资源。</li><li><strong>生成响应</strong>：如果是静态网站，服务器通常直接返回存储的HTML、CSS和JavaScript文件。如果是动态内容，服务器可能需要先执行一些后端逻辑。</li></ul><h3 id="5-服务器响应"><a href="#5-服务器响应" class="headerlink" title="5. 服务器响应"></a>5. 服务器响应</h3><ul><li><strong>发送响应</strong>：服务器向浏览器发送一个响应，通常包括一个状态码（如200表示成功），响应头信息，以及请求的实际数据（通常是HTML文档）。</li></ul><h3 id="6-浏览器处理响应"><a href="#6-浏览器处理响应" class="headerlink" title="6. 浏览器处理响应"></a>6. 浏览器处理响应</h3><ul><li><strong>解析HTML</strong>：浏览器开始解析服务器返回的HTML文档。解析过程中，它会构建DOM（文档对象模型）树。</li><li><strong>请求额外资源</strong>：如果HTML中引用了额外资源（如CSS文件、JavaScript文件、图片等），浏览器会发送额外的HTTP请求来获取这些资源。</li><li><strong>构建CSSOM</strong>：浏览器解析CSS文件并构建CSSOM（CSS对象模型）树。</li><li><strong>JavaScript执行</strong>：JavaScript文件被下载并执行，可能会修改DOM和CSSOM。</li></ul><h3 id="7-渲染页面"><a href="#7-渲染页面" class="headerlink" title="7. 渲染页面"></a>7. 渲染页面</h3><ul><li><strong>构建渲染树</strong>：浏览器结合DOM和CSSOM来创建渲染树，它代表了页面的可视化结构。</li><li><strong>布局计算</strong>：计算渲染树中每个节点的大小和位置。</li><li><strong>绘制页面</strong>：浏览器根据渲染树和布局信息在屏幕上绘制页面内容。</li></ul><h3 id="8-用户交互"><a href="#8-用户交互" class="headerlink" title="8. 用户交互"></a>8. 用户交互</h3><ul><li>页面加载完毕后，用户可以与页面进行交互，如点击链接、填写表单等。这些交互可能会触发JavaScript事件，进而导致页面的部分或全部重新渲染。</li></ul><p>这个过程虽然听起来复杂且步骤繁多，但实际上在现代网络环境下通常只需几秒钟即可完成。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CNAME记录和A记录</title>
      <link href="/2023/10/30/CNAME%E8%AE%B0%E5%BD%95%E5%92%8CA%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/30/CNAME%E8%AE%B0%E5%BD%95%E5%92%8CA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>CNAME记录和A记录都是DNS（域名系统）中的重要部分，它们在将域名解析到IP地址时起着关键作用。</p><h3 id="A记录（Address-Record）"><a href="#A记录（Address-Record）" class="headerlink" title="A记录（Address Record）"></a>A记录（Address Record）</h3><ul><li><strong>作用</strong>：A记录用于将域名直接映射到IPv4地址。当你输入一个网站域名时，DNS通过查找相应的A记录，将该域名解析为一个IP地址，从而使你的设备可以找到并连接到托管该网站的服务器。</li><li><strong>示例</strong>：如果你拥有一个域名如 <code>example.com</code>，你可以设置一个A记录来指定这个域名应该被解析到的IPv4地址，比如 <code>192.0.2.1</code>。</li></ul><h3 id="CNAME记录（Canonical-Name-Record）"><a href="#CNAME记录（Canonical-Name-Record）" class="headerlink" title="CNAME记录（Canonical Name Record）"></a>CNAME记录（Canonical Name Record）</h3><ul><li><strong>作用</strong>：CNAME记录用于将一个域名映射到另一个域名。它通常用于为同一IP地址上的多个域名提供服务，或者在使用第三方服务（如GitHub Pages或CDN服务）时将你的自定义域名映射到这些服务提供的域名上。</li><li><strong>示例</strong>：如果你有一个域名 <code>blog.example.com</code> 并且希望它指向 <code>example.com</code> 上的内容，你可以为 <code>blog.example.com</code> 设置一个CNAME记录，指向 <code>example.com</code>。这样，当用户访问 <code>blog.example.com</code> 时，他们实际上看到的是 <code>example.com</code> 的内容。</li></ul><h3 id="使用场景和注意事项"><a href="#使用场景和注意事项" class="headerlink" title="使用场景和注意事项"></a>使用场景和注意事项</h3><ul><li><strong>使用场景</strong>：<ul><li>A记录通常用于直接将根域（如 <code>example.com</code>）映射到服务器的IP地址。</li><li>CNAME记录用于将子域（如 <code>www.example.com</code> 或 <code>blog.example.com</code>）映射到另一个域名，或者在你想要确保即使IP地址变化也不影响访问时使用。</li></ul></li><li><strong>注意事项</strong>：<ul><li>CNAME记录不能用于根域（naked domain），因为根域需要有SOA（Start of Authority）记录和NS（Name Server）记录，这与CNAME记录冲突。</li><li>使用CNAME记录时，任何对该域名的请求都将继承目标域名的所有DNS记录。这意味着如果你设置 <code>blog.example.com</code> 的CNAME记录指向 <code>example.com</code>，那么 <code>blog.example.com</code> 也将继承 <code>example.com</code> 的所有记录，包括A记录、MX记录等。</li></ul></li></ul><p>在配置DNS时，正确选择并使用这两种记录对于确保域名解析的正确性和效率至关重要。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关联矩阵，邻接矩阵，拉普拉斯矩阵</title>
      <link href="/2023/10/26/%E6%96%B9%E5%90%91/%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5,%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5,%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/10/26/%E6%96%B9%E5%90%91/%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5,%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5,%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>关联矩阵和邻接矩阵都是用于表示图（Graph）的矩阵，但它们关心的内容和表示方法有所不同。</p><ol><li><strong>邻接矩阵（Adjacency Matrix）</strong>:<ul><li>针对于图中的<strong>顶点</strong>来构建矩阵。</li><li>矩阵的行和列都代表图中的顶点。</li></ul></li></ol><ul><li>如果两个顶点之间有一条边，那么矩阵中对应的位置的值为1（对于无权图）或为边的权重（对于有权图）；否则为0。  例如，考虑一个无向图，其中有三个顶点：A、B 和 C。假设A和B之间有一条边，B和C之间也有一条边。邻接矩阵如下：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    A B C</span><br><span class="line">A [ 0 1 0 ]</span><br><span class="line">B [ 1 0 1 ]</span><br><span class="line">C [ 0 1 0 ]</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>关联矩阵（Incidence Matrix）</strong>:<ul><li>用于描述<strong>顶点</strong>和<strong>边</strong>之间的关系。</li><li>矩阵的行代表图中的顶点，而列代表图中的边。</li><li>对于<strong>无向图</strong>，如果某个顶点与某条边关联（即该边的一个端点就是该顶点），那么对应的矩阵元素为1，否则为0。</li></ul></li></ol><ul><li>对于<strong>有向图</strong>，如果某条边从某个顶点出发，则对应的矩阵元素为-1；如果该边指向该顶点，则为1；否则为0。  继续上面的例子，对于无向图中的三个顶点A、B、C，设A和B之间的边为e1，B和C之间的边为e2。关联矩阵如下：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     e1 e2</span><br><span class="line">A [  1  0 ]</span><br><span class="line">B [  1  1 ]</span><br><span class="line">C [  0  1 ]</span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><ul><li>邻接矩阵主要关心顶点间是否存在边，它是一个方阵（行数等于列数），因为它只涉及顶点。</li><li>关联矩阵主要关心顶点和边的关系，它的行数等于顶点数，列数等于边数。</li></ul><p>拉普拉斯矩阵（Laplacian Matrix），也被称为图拉普拉斯矩阵或Kirchhoff矩阵，是图论中描述图的一个重要矩阵。它捕捉了图的结构信息，尤其在图的谱理论中起着关键作用。</p><p>对于一个简单的无向图 (G=(V, E)) 其中 (V) 代表顶点集合， (E) 代表边集合，其拉普拉斯矩阵 (L) 定义为：</p><p>[ L = D - A ]</p><p>其中：</p><ul><li>(D) 是图的度矩阵，一个对角矩阵，其对角线上的元素 (D_{ii}) 是顶点 (i) 的度数（与该顶点相连的边的数量）。</li><li>(A) 是图的邻接矩阵。</li></ul><p>拉普拉斯矩阵的一些性质：</p><ol><li>对于任何向量 (x)，我们都有 (x^T L x \geq 0)。因此，拉普拉斯矩阵是半正定的。</li><li>拉普拉斯矩阵的所有特征值都是非负的。</li><li>拉普拉斯矩阵的最小特征值为0，其对应的特征向量是全1向量。</li><li>如果图是连通的，那么0是拉普拉斯矩阵的单一特征值，且其重数为1。</li></ol><p>例子：</p><p>考虑一个简单的无向图，包括3个顶点：A、B、C。A和B之间有一条边，A和C之间也有一条边。它的邻接矩阵和度矩阵如下：</p><p>邻接矩阵 (A):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    A B C</span><br><span class="line">A [ 0 1 1 ]</span><br><span class="line">B [ 1 0 0 ]</span><br><span class="line">C [ 1 0 0 ]</span><br></pre></td></tr></table></figure><p>度矩阵 (D):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    A B C</span><br><span class="line">A [ 2 0 0 ]</span><br><span class="line">B [ 0 1 0 ]</span><br><span class="line">C [ 0 0 1 ]</span><br></pre></td></tr></table></figure><p>拉普拉斯矩阵 (L = D - A):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    A  B  C</span><br><span class="line">A [ 2 -1 -1 ]</span><br><span class="line">B [-1  1  0 ]</span><br><span class="line">C [-1  0  1 ]</span><br></pre></td></tr></table></figure><p>拉普拉斯矩阵在多个领域，如图像处理、数据聚类和网络科学等，都有广泛的应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>istringstream的使用</title>
      <link href="/2023/10/25/istringstream%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/25/istringstream%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>istringstream</code> 是 C++ 标准库中的一个类，它位于头文件 <code>&lt;sstream&gt;</code> 中。名称 <code>istringstream</code> 是 “input string stream” 的缩写，表示这是一个提供对 <code>string</code> 进行流式输入操作的类。</p><p><code>istringstream</code> 对象可以从一个字符串中读取数据，就像从输入流（例如 <code>cin</code>）中读取数据一样。这使得 <code>istringstream</code> 成为从字符串中解析数据的非常有用的工具。</p><p><strong>基本使用</strong>：</p><ol><li><p><strong>初始化</strong>：你可以使用一个字符串来初始化 <code>istringstream</code> 对象。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>从流中读取</strong>：使用 <code>&gt;&gt;</code> 运算符，就像你从其他输入流中读取一样。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">iss &gt;&gt; a &gt;&gt; b;  <span class="comment">// a = 123, b = 456</span></span><br></pre></td></tr></table></figure></li><li><p>**使用 <code>getline</code>**：你可以使用 <code>getline</code> 函数与 <code>istringstream</code> 对象配合，从字符串中读取行或使用特定的分隔符分割字符串。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string input = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line">string token;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(iss, token, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; token &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// orange</span></span><br></pre></td></tr></table></figure></li></ol><p>**为什么使用 <code>istringstream</code>**：</p><ol><li><strong>灵活性</strong>：它允许你将字符串视为流，从而可以使用流的操作来进行各种操作，如提取、分割等。</li><li><strong>类型转换</strong>：它可以自动将字符串内容转换为其他数据类型。例如，从包含数字的字符串中提取整数或浮点数。</li><li><strong>字符串分割</strong>：与 <code>getline</code> 配合使用，可以方便地分割字符串。</li></ol><p>总之，<code>istringstream</code> 是处理和解析字符串数据的强大工具，特别是当你需要以流的方式处理字符串或将字符串内容转换为其他数据类型时。</p><h5 id="leetcode-468"><a href="#leetcode-468" class="headerlink" title="leetcode 468"></a>leetcode 468</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string validIPAddress(string IP) &#123;</span><br><span class="line">        if (count(IP.begin(), IP.end(), &#x27;.&#x27;) == 3) &#123;</span><br><span class="line">            if (isValidIPv4(IP)) return &quot;IPv4&quot;;</span><br><span class="line">        &#125; else if (count(IP.begin(), IP.end(), &#x27;:&#x27;) == 7) &#123;</span><br><span class="line">            if (isValidIPv6(IP)) return &quot;IPv6&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Neither&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Helper function to check valid IPv4</span><br><span class="line">    bool isValidIPv4(string IP) &#123;</span><br><span class="line">        istringstream ss(IP);</span><br><span class="line">        string token;</span><br><span class="line">        while (getline(ss, token, &#x27;.&#x27;)) &#123;</span><br><span class="line">            // Length check</span><br><span class="line">            if (token.empty() || token.size() &gt; 3) return false;</span><br><span class="line">            </span><br><span class="line">            // Leading zero check</span><br><span class="line">            if (token.size() &gt; 1 &amp;&amp; token[0] == &#x27;0&#x27;) return false;</span><br><span class="line">            </span><br><span class="line">            // Only digits check</span><br><span class="line">            for (char c : token) &#123;</span><br><span class="line">                if (!isdigit(c)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Convert token to integer and check range</span><br><span class="line">            int val = stoi(token);</span><br><span class="line">            if (val &lt; 0 || val &gt; 255) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return ss.eof();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check valid IPv6</span><br><span class="line">    bool isValidIPv6(string IP) &#123;</span><br><span class="line">        istringstream ss(IP);</span><br><span class="line">        string token;</span><br><span class="line">        while (getline(ss, token, &#x27;:&#x27;)) &#123;</span><br><span class="line">            // Length check</span><br><span class="line">            if (token.empty() || token.size() &gt; 4) return false;</span><br><span class="line">            </span><br><span class="line">            // Check valid hex characters</span><br><span class="line">            for (char c : token) &#123;</span><br><span class="line">                if (!isxdigit(c)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ss.eof();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么类必须实例化之后才能调用函数?</title>
      <link href="/2023/10/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E6%89%8D%E8%83%BD%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E6%89%8D%E8%83%BD%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>类中的函数（或称为方法）可以大致分为两类：非静态方法和静态方法。</p><ol><li>**非静态方法 (Instance Methods)**：<ul><li>当你定义一个非静态方法，它通常需要访问或修改类的实例成员（属性或其他方法）。这些实例成员在每个类的实例中可能有不同的值。</li><li>要调用非静态方法，你需要首先创建类的实例，因为该方法可能要操作该实例的特定数据。这就是为什么你需要实例化类来调用它的非静态方法。</li></ul></li></ol><p>举例：考虑一个<code>Person</code>类，其中有一个方法<code>getName()</code>返回该人的名字。因为每个人的名字都可能不同，你需要针对特定的<code>Person</code>实例调用这个方法来得到他/她的名字。</p><ol start="2"><li>**静态方法 (Static Methods)**：<ul><li>静态方法与类相关，而不是与特定的类实例相关。因此，它们不能访问非静态的实例成员。但它们可以访问类的静态成员。</li><li>你可以在不创建类实例的情况下调用静态方法，通常通过<code>类名.静态方法名</code>的形式来调用。</li></ul>举例：考虑一个工具类<code>MathUtils</code>，其中有一个静态方法<code>add()</code>用于计算两个数字的和。这个方法与特定的<code>MathUtils</code>实例无关，因为它只是执行数学操作，所以你可以直接调用它，如<code>MathUtils.add(1, 2)</code>。</li></ol><p><strong>总结</strong>：你需要实例化类来调用其非静态方法，因为这些方法通常要操作或访问特定实例的数据。而静态方法与特定的实例无关，所以你可以直接调用它，而不需要实例化类。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍sprintf()函数</title>
      <link href="/2023/10/16/sprintf%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/16/sprintf%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><code>sprintf</code> 是 C 和 C++ 中的一个标准库函数，用于字符串的格式化输出。它允许你将各种数据类型格式化为字符串形式，并将结果保存到一个字符数组中。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li><p><code>str</code>：这是一个字符数组的指针，用于存放格式化后的结果字符串。</p></li><li><p><code>format</code>：这是格式化字符串，它可以包含普通字符以及格式说明符。格式说明符用于指定如何格式化后面的参数。例如，<code>%d</code> 用于整数，<code>%f</code> 用于浮点数，<code>%s</code> 用于字符串等。</p></li><li><p><code>...</code>：这是一个变长参数列表，它表示零个或多个要格式化的值。这些值的类型和数量应该与 <code>format</code> 字符串中的格式说明符相匹配。</p></li></ol><p>返回值：<br><code>sprintf</code> 返回写入 <code>str</code> 的字符数，不包括结尾的空字符。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Integer: %d, Float: %f&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);  <span class="comment">// 输出: Integer: 5, Float: 3.140000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>使用 <code>sprintf</code> 时需要确保目标字符数组有足够的空间来存放格式化后的结果。否则，如果写入的字符超出了数组的大小，会导致缓冲区溢出，这是一个常见的安全漏洞。</li><li>如果对目标缓冲区的大小有疑虑，建议使用 <code>snprintf</code>，这是一个更安全的版本，允许你指定最大的写入字符数，从而避免缓冲区溢出。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么静态成员函数没有隐含的this指针？</title>
      <link href="/2023/10/14/ncre/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9A%90%E5%90%AB%E7%9A%84this%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/14/ncre/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9A%90%E5%90%AB%E7%9A%84this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>静态成员函数没有隐含的this指针的原因是它们与类的实例对象无关。以下是解释为什么静态成员函数没有this指针的主要原因：</p><ol><li><p><strong>独立于实例对象</strong>：静态成员函数属于整个类，而不是类的特定实例对象。它们在类的命名空间中定义，不依赖于特定的对象实例。因此，没有必要为每个静态成员函数分配一个this指针，因为this指针通常用于引用类的实例对象的成员变量和成员函数。</p></li><li><p><strong>无法访问非静态成员</strong>：静态成员函数只能访问静态成员变量和静态成员函数，它们无法访问类的非静态成员（即实例变量和成员函数），因为没有与之关联的this指针。this指针用于访问实例成员，但静态函数没有实例上下文，因此无法使用this指针来访问实例成员。</p></li><li><p><strong>调用方式不同</strong>：静态成员函数可以使用类名来调用，而不需要创建类的实例。例如，如果有一个名为<code>MyClass</code>的类，并且它有一个静态成员函数<code>staticFunction()</code>，则可以使用<code>MyClass::staticFunction()</code>来调用它，而不需要创建<code>MyClass</code>的对象。这种调用方式反映了静态成员函数的独立性，因此不需要隐含的this指针。</p></li></ol><p>因此，静态成员函数被设计成与类的实例对象无关，因此不具有隐含的this指针。这使得它们更适合执行与类相关但不依赖于特定对象实例的操作，例如工具函数、全局操作等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类中析构函数的作用</title>
      <link href="/2023/10/14/ncre/%E7%B1%BB%E4%B8%AD%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/14/ncre/%E7%B1%BB%E4%B8%AD%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>类中的析构函数（Destructor）是一个特殊的成员函数，它在对象被销毁时自动调用，负责释放对象所占用的资源和执行清理操作。析构函数的名称是在类名称前加上波浪号（~）。</p><p>析构函数的主要作用是在对象生命周期结束时进行资源的回收，如释放动态分配的内存、关闭文件、释放网络连接等。它与构造函数（Constructor）相对应，构造函数在对象创建时执行初始化操作，而析构函数在对象销毁时执行清理操作。</p><p>析构函数的特点和用法如下：</p><ol><li><p>声明和定义：析构函数的声明和定义都不需要返回类型，也不接受任何参数。它只能有一个析构函数，没有重载的概念。</p></li><li><p>调用时机：析构函数的调用时机是在对象的生命周期结束时自动触发。这可以发生在对象离开其作用域、delete掉动态分配的对象、或者程序结束时（全局对象）。</p></li><li><p>编译器默认析构函数：如果你没有为类显式定义析构函数，编译器会为你生成一个默认的析构函数。这个默认析构函数会执行成员变量的销毁，但对于动态分配的资源，可能无法正确释放，因此在有需要的情况下，最好显式定义析构函数。</p></li><li><p>用户自定义析构函数：当类中有需要手动释放的资源（例如动态分配的内存），或需要进行额外的清理操作时，就需要显式定义析构函数。例如：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 清理操作，释放资源等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>逆序调用：在继承关系中，析构函数会按照派生类到基类的逆序调用。即先调用派生类的析构函数，再调用基类的析构函数。</p></li><li><p>不应手动调用析构函数：析构函数应由系统自动调用，不应手动调用。例如，不要在代码中显式地调用<code>obj.~MyClass();</code>来销毁对象。</p></li></ol><p>在使用类时，尤其是涉及到资源管理的情况下，正确实现析构函数是非常重要的，以防止内存泄漏和资源泄漏等问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作符重载</title>
      <link href="/2023/10/14/ncre/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/10/14/ncre/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>1.操作符重载的定义<br>2.操作符重载是一个特殊的函数,该函数名称以operator关键字加需要重载的操作符组成。<br>3.重载操作符的数目和操作符的操作数目相同(成员函数第一个参数默认是this).<br>4.操作符重载主要应用在类类型，内置类型含义不能改变。<br>5.重载操作符函数可以定义为成员函数或非成员函数。<br>6.搡作符为非成员函数时,通常必须将它们设置为所操作类的友元。<br>7.使用重载操作符。可以像函数调用一样,也可以像使用普通操作符一样。<br>8.实例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器会在类内部帮你构造一个默认的成员赋值操作符 ，逻辑就是照抄内存 ， 这就是我们自己定义的类通常也能自己赋值的原因 (故赋值操作符不能声明为非友元函数)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> pid;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> pid, string name, <span class="type">int</span> age):<span class="built_in">pid</span>(pid),<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; per)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;clnsssss&quot;</span> &lt;&lt; endl; </span><br><span class="line">pid = per.pid;</span><br><span class="line">name = per.name; </span><br><span class="line">age = per.age;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person per;</span><br><span class="line"><span class="function">Person <span class="title">per2</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">per = per2;</span><br><span class="line"></span><br><span class="line">per.<span class="built_in">display</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>析构函数的调用时间</title>
      <link href="/2023/10/14/ncre/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4/"/>
      <url>/2023/10/14/ncre/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>析构函数在以下情况下会被自动调用：</p><ol><li>当对象离开其作用域：当一个对象在其定义的作用域结束时，该对象的析构函数会被自动调用。例如，在函数中创建的局部对象将在函数结束时调用其析构函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 构造函数被调用</span></span><br><span class="line">&#125; <span class="comment">// 作用域结束，析构函数被调用</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对象通过 <code>delete</code> 运算符销毁：如果对象是通过 <code>new</code> 运算符在堆上创建的，那么在使用 <code>delete</code> 运算符删除对象时，对象的析构函数将被调用。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass* ptr = <span class="keyword">new</span> MyClass; <span class="comment">// 构造函数被调用</span></span><br><span class="line"><span class="keyword">delete</span> ptr;                 <span class="comment">// 析构函数被调用</span></span><br></pre></td></tr></table></figure><ol start="3"><li>对象是容器的元素：如果对象是容器（如 <code>std::vector</code>、<code>std::list</code> 等）的元素，并且容器被销毁或者元素被从容器中移除，那么元素的析构函数将被调用。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;MyClass&gt; myVector;</span><br><span class="line">myVector.<span class="built_in">push_back</span>(<span class="built_in">MyClass</span>()); <span class="comment">// 构造函数被调用</span></span><br><span class="line">myVector.<span class="built_in">pop_back</span>();           <span class="comment">// 析构函数被调用</span></span><br></pre></td></tr></table></figure><ol start="4"><li>当对象是全局对象时，在程序结束时析构函数会被调用。这通常用于清理全局对象分配的资源。</li></ol><p>请注意，析构函数的主要作用是释放对象所拥有的资源，如动态分配的内存、打开的文件、网络连接等。如果类不需要进行资源管理，通常可以不编写析构函数，因为C++会提供一个默认的析构函数，它不执行特定的清理操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指针常量和常量指针</title>
      <link href="/2023/10/14/ncre/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/14/ncre/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>指针常量和常量指针是与C和C++编程语言中指针相关的两个重要概念，它们涉及了指针和常量的组合。让我为您详细介绍它们：</p><ol><li><p><strong>指针常量（Pointer to Constant）</strong>：</p><ul><li><p>指针常量是一个指针，它指向一个常量值，这意味着通过该指针无法修改所指向的值，但可以修改指针本身。</p></li><li><p>声明指针常量时，通常会使用<code>const</code>关键字来修饰指针指向的内容。</p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;         <span class="comment">// 定义一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;x;      <span class="comment">// 声明一个指向常量的指针</span></span><br><span class="line">*ptr = <span class="number">20</span>;                <span class="comment">// 错误，无法通过ptr修改x的值</span></span><br><span class="line">ptr++;                    <span class="comment">// 合法，可以改变ptr指向的位置</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常量指针（Constant Pointer）</strong>：</p><ul><li><p>常量指针是一个指向变量的指针，但它自身不能指向其他变量，这意味着它一旦指向了某个变量，就无法再指向其他变量，但可以通过该指针修改所指向的变量的值。</p></li><li><p>声明常量指针时，通常会在指针变量前使用<code>const</code>关键字。</p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span>;                <span class="comment">// 定义一个变量</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;y;      <span class="comment">// 声明一个常量指针</span></span><br><span class="line">*ptr = <span class="number">20</span>;                <span class="comment">// 合法，可以通过ptr修改y的值</span></span><br><span class="line">ptr++;                    <span class="comment">// 错误，无法改变ptr指向的位置</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>总结：</p><ul><li>指针常量强调不能通过指针修改所指向的内容，但可以改变指针本身的指向。</li><li>常量指针强调指针的指向是固定的，不能指向其他变量，但可以通过指针修改所指向的内容。</li></ul><p>这些概念在编程中非常重要，特别是在保护数据不被意外修改或者在函数参数中传递数据时，可以根据需要选择使用指针常量或常量指针。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>引用和解引用</title>
      <link href="/2023/10/14/ncre/%E5%BC%95%E7%94%A8%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8/"/>
      <url>/2023/10/14/ncre/%E5%BC%95%E7%94%A8%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>引用和解引用是与指针有关的两个重要概念，用于访问和操作内存中的数据。</p><p><strong>引用 (Reference):</strong><br>引用是一个别名，它允许我们使用一个变量的不同名称来引用相同的内存位置。在C++中，引用使用 <code>&amp;</code> 符号来声明，并且在声明时必须初始化。引用通常用于函数参数传递和函数返回值，以提高代码的可读性和效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;y = x; <span class="comment">// 创建一个对x的引用y</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">20</span>; <span class="comment">// 这实际上会修改x的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>y</code> 是对 <code>x</code> 的引用，所以对 <code>y</code> 的任何操作都会影响到 <code>x</code>，因为它们引用了相同的内存位置。因此，修改 <code>y</code> 的值实际上修改了 <code>x</code> 的值。</p><p><strong>解引用 (Dereference):</strong><br>解引用是通过指针访问指针所指向的内存位置的过程。在C++中，解引用使用 <code>*</code> 符号。当你有一个指针时，你可以使用解引用操作符 <code>*</code> 来访问指针指向的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;x; <span class="comment">// 创建一个指向x的指针ptr</span></span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">30</span>; <span class="comment">// 通过解引用操作修改x的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; *ptr: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>ptr</code> 是指向 <code>x</code> 的指针，通过 <code>*ptr</code>，我们可以访问并修改 <code>x</code> 的值。解引用操作允许我们在不直接使用变量名的情况下访问和修改变量的值，而是通过指针来完成。</p><p>总结：</p><ul><li>引用是一个别名，它允许使用不同的名称访问相同的内存位置，通常用于提高代码可读性和效率。</li><li>解引用是通过指针访问指针所指向的内存位置的操作，通过 <code>*</code> 符号完成。它允许我们访问和修改内存中的数据。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2023/10/14/ncre/%E5%A4%9A%E6%80%81/"/>
      <url>/2023/10/14/ncre/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>1.虚函数是实现多态的基础，多态是指一个函数有多种状态。根据实际对象在运行期间动态调用相应的方法。</p><p>2.多态实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USB</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>=<span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> : <span class="keyword">public</span> USB</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;from computer read&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;write to computer&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mobile</span> : <span class="keyword">public</span> USB </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;from mobile read&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;write to mobile&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">(USB &amp;usb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">usb.<span class="built_in">read</span>();</span><br><span class="line">usb.<span class="built_in">write</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person per;</span><br><span class="line"></span><br><span class="line">USB *usb;</span><br><span class="line">Computer c;</span><br><span class="line">usb = &amp;c;</span><br><span class="line"></span><br><span class="line">per.<span class="built_in">use</span>(*usb);</span><br><span class="line"></span><br><span class="line">Mobile m;</span><br><span class="line">usb = &amp;m;</span><br><span class="line"></span><br><span class="line">per.<span class="built_in">use</span>(*usb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数参数的传递方式</title>
      <link href="/2023/10/14/ncre/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/10/14/ncre/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f1(int x);</span><br><span class="line">void f2(int *x);</span><br><span class="line">void f3(const int *x);</span><br><span class="line">void f4(int &amp;x);</span><br></pre></td></tr></table></figure><p>你提供了四个不同的C++函数声明，分别有不同的参数类型。让我来解释一下每一个：</p><ol><li><p><code>void f1(int x);</code></p><ul><li>这是一个函数声明，它接受一个整数<code>x</code>作为值传递。这意味着函数将接收整数<code>x</code>的一个副本，在函数内对<code>x</code>的任何修改都不会影响函数外部的原始变量。</li></ul></li><li><p><code>void f2(int *x);</code></p><ul><li>这是一个函数声明，它接受一个指向整数<code>x</code>的指针。在函数内部，您可以通过解引用指针使用<code>*x</code>间接地操纵<code>x</code>的值。</li></ul></li><li><p><code>void f3(const int *x);</code></p><ul><li>这是一个函数声明，它接受一个指向常量整数<code>x</code>的指针。<code>const</code>关键字表示函数承诺不会修改指向<code>x</code>的值。这是一种表达函数不会通过这个指针修改原始数据的方式。</li></ul></li><li><p><code>void f4(int &amp;x);</code></p><ul><li>这是一个函数声明，它通过引用接受一个整数<code>x</code>。当通过引用传递参数时，在函数内对<code>x</code>的任何修改都将直接影响函数外部的原始变量。这实际上允许您传递变量本身，而不是副本。</li></ul></li></ol><p>这里是这些函数的简单使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f1</span>(num);  <span class="comment">// 值传递，num仍然是42</span></span><br><span class="line">    <span class="built_in">f2</span>(&amp;num); <span class="comment">// 通过指针传递，可以间接修改num</span></span><br><span class="line">    <span class="built_in">f3</span>(&amp;num); <span class="comment">// 通过指向常量的指针传递，无法通过f3修改num</span></span><br><span class="line">    <span class="built_in">f4</span>(num);  <span class="comment">// 通过引用传递，可以直接修改num</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，函数<code>f2</code>和<code>f4</code>的行为将直接影响函数外部的<code>num</code>变量，而<code>f1</code>和<code>f3</code>不会修改原始变量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>private, protected, public</title>
      <link href="/2023/10/14/ncre/private,protected,public%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/10/14/ncre/private,protected,public%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内联函数</title>
      <link href="/2023/10/14/ncre/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/14/ncre/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>内联函数（Inline Functions）是一种用于优化代码执行速度的编程技术，通常在C++中使用。内联函数的主要思想是将函数的代码插入到调用它的地方，而不是通过常规的函数调用机制来执行函数。这样可以减少函数调用的开销，提高程序的执行效率。</p><p>以下是关于内联函数的一些重要信息：</p><ol><li><strong>声明与定义：</strong> 内联函数通常在类定义中声明，并在类外部定义。声明和定义都需要使用 <code>inline</code> 关键字。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span></span>; <span class="comment">// 内联函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MyClass::myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内联函数的定义</span></span><br><span class="line">    <span class="comment">// 函数体的代码将在调用点内联</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>适用情况：</strong> 内联函数通常适用于函数体较小的函数，因为它们的代码将被插入到每个调用点，如果函数体过大，可能会导致代码膨胀。通常用于简单的访问器（getter）和设置器（setter）函数，以及执行小而频繁调用的操作。</p></li><li><p><strong>优点：</strong> 内联函数的主要优点是减少函数调用的开销。函数调用涉及保存和恢复上下文、跳转到函数体、返回值的传递等操作，而内联函数直接将代码插入到调用点，省去了这些开销。</p></li><li><p><strong>注意事项：</strong> 内联函数并不是在所有情况下都适用的。过度使用内联可能导致代码膨胀，增加可执行文件的大小。编译器通常会根据情况自动决定是否内联函数。你可以使用 <code>inline</code> 关键字进行建议，但不是命令编译器必须内联函数。</p></li><li><p><strong>编译器依赖性：</strong> 内联函数的内联与否取决于编译器的实现和优化策略。不同编译器可能会在不同情况下选择是否内联函数。</p></li><li><p><strong>递归和虚函数：</strong> 内联函数通常不适用于递归函数或虚函数，因为它们的调用机制较为复杂。</p></li></ol><p>总之，内联函数是一种有助于提高代码执行速度的技术，但需要谨慎使用。在编写内联函数时，你应该权衡代码大小和执行速度，以确保它们在适当的地方使用。</p><p>让我们通过一个简单的示例来说明内联函数的用法和效果。</p><p>假设我们有一个简单的 <code>Vector</code> 类，用于表示二维向量，并且我们想定义一个内联的成员函数来计算向量的模（长度）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内联函数：计算向量的模</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">CalculateMagnitude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x_ * x_ + y_ * y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内联函数 CalculateMagnitude，它将在调用点内联执行</span></span><br><span class="line">    <span class="type">double</span> magnitude = v.<span class="built_in">CalculateMagnitude</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector magnitude: &quot;</span> &lt;&lt; magnitude &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个 <code>Vector</code> 类，其中包含一个成员函数 <code>CalculateMagnitude()</code>，用于计算向量的模。我们使用 <code>inline</code> 关键字将这个函数标记为内联函数。</p><p>在 <code>main()</code> 函数中，我们创建了一个 <code>Vector</code> 对象 <code>v</code>，然后调用了 <code>CalculateMagnitude()</code> 函数来计算向量的模。由于函数被标记为内联，它的代码将被插入到调用点。这意味着函数调用的开销非常小，因为没有实际的函数调用和返回过程，而是直接在调用点执行了函数体的代码。</p><p>这个示例中的内联函数非常简单，但对于小型的、频繁调用的操作，内联函数可以提高代码的执行效率。但请注意，过度使用内联函数可能会导致代码膨胀，因此应该在需要的地方使用，并依赖于编译器的优化来决定是否内联。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>private, protected, public</title>
      <link href="/2023/10/14/ncre/private,%20protected,public%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/10/14/ncre/private,%20protected,public%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在面向对象编程中，<code>private</code>、<code>protected</code> 和 <code>public</code> 是用于控制类成员的访问权限的访问修饰符，它们决定了类的成员（包括变量和函数）可以被哪些代码访问。这些访问修饰符在C++、Java、C#等面向对象编程语言中都有类似的概念。</p><ol><li><p><strong>private（私有）</strong>：</p><ul><li>成员被声明为<code>private</code>，只能在类的内部访问，类外部的任何代码都无法直接访问这些成员。</li><li><code>private</code> 成员通常用于实现封装，将数据隐藏在类的内部，只允许通过公有接口（公有成员函数）来访问和修改数据。</li><li>通过类的公有成员函数可以间接访问和修改<code>private</code> 成员。</li></ul></li><li><p><strong>protected（受保护）</strong>：</p><ul><li>成员被声明为<code>protected</code>，可以在类的内部和派生类中访问，但在类的外部无法直接访问。</li><li><code>protected</code> 成员通常用于实现继承，允许派生类访问基类的成员，但阻止外部代码访问。</li><li>在C++中，<code>protected</code> 成员可以被派生类的成员函数和友元函数访问，但不能被派生类的对象访问。</li></ul></li><li><p><strong>public（公有）</strong>：</p><ul><li>成员被声明为<code>public</code>，可以在类的内部、派生类中和类的外部任何地方访问。</li><li><code>public</code> 成员用于定义类的公有接口，外部代码可以直接访问这些成员，从而与类进行交互。</li><li>公有成员函数通常用于提供对象的操作接口。</li></ul></li></ol><p>访问修饰符的选择取决于你希望如何封装和暴露类的成员。一般来说，良好的封装和隐藏细节是面向对象编程的关键原则，因此大多数成员应该被声明为<code>private</code>，只有必要的接口才应该被声明为<code>public</code> 或<code>protected</code>。这有助于提高代码的可维护性、可重用性和安全性，同时隐藏内部实现的细节。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中虚函数和纯虚函数</title>
      <link href="/2023/10/14/ncre/C++%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/14/ncre/C++%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，虚函数和纯虚函数是用于实现多态性和基类抽象的重要概念。</p><ol><li><p>虚函数（Virtual Function）：</p><ul><li>虚函数是在基类中声明为 <code>virtual</code> 的成员函数。派生类可以通过继承虚函数并对其进行重写，从而实现多态性。</li><li>当通过基类指针或引用调用虚函数时，实际调用的是派生类中重写的函数。这种行为称为动态绑定，使得程序在运行时能够根据实际对象类型决定调用哪个函数。</li><li>虚函数提供了一种机制，使得可以通过基类指针或引用调用派生类的特定实现，实现了基类和派生类之间的多态性。</li></ul></li><li><p>纯虚函数（Pure Virtual Function）：</p><ul><li>纯虚函数是在基类中声明为纯虚函数的虚函数，它没有具体的实现，只提供了接口。在基类中使用 <code>virtual</code> 关键字声明函数，然后使用 <code>= 0</code> 指定函数为纯虚函数。</li><li>纯虚函数用于将基类定义为抽象类，不能创建该类的对象，只能用作其他类的基类。</li><li>派生类必须实现基类中的纯虚函数，否则派生类也会成为抽象类。</li><li>纯虚函数的主要目的是为了定义一个接口，要求派生类提供特定的实现。这样可以在基类中定义通用的行为和接口，而将特定的实现留给派生类来完成。</li></ul></li></ol><p>使用虚函数和纯虚函数可以实现多态性和基类抽象的特性，使得程序具有更灵活和可扩展的设计。虚函数提供了动态绑定的能力，而纯虚函数用于定义接口和实现基类抽象。</p><p>一说到虚函数，马上想到几个概念</p><ol><li>将非静态成员函数添加virtual关键字，会得到虚函数</li><li>虚函数是用来实现多态，或者动态绑定的</li></ol><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>​    指的是，原本调用一个函数名，编译的时候就决定了将来会执行哪个函数，加上virtual之后，这个确定的过程被延迟到了运行期间。要触发动态绑定（也就是多态），必须满足两个条件：第一，虚函数。第二，必须通过基类的引用或指针进行函数调用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>优化输入输出</title>
      <link href="/2023/10/14/cin.tie/"/>
      <url>/2023/10/14/cin.tie/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);   </span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这两行的作用是什么</p><p>这两行代码是用来优化输入输出操作的。</p><p><code>ios::sync_with_stdio(false);</code> 是一个函数调用，它会将 C++ 的 I/O 流与 C 的标准 I/O 流解绑，以提高输入输出的效率。默认情况下，C++ 的输入输出流与 C 的标准 I/O 流是同步的，这意味着在进行输入输出操作时，C++ 输入输出流会先进行缓冲区同步，然后再执行实际的读写操作。但是，这种同步操作会引入一些额外的开销，尤其是在大量的输入输出操作中。</p><p><code>cin.tie(0);</code> 是用来取消 cin 和 cout 之间的关联，以进一步提高输入输出的效率。默认情况下，cin 和 cout 是关联的，这意味着在每次进行输入操作时，输出缓冲区会被刷新，以确保之前的输出被正确显示。但是，这种关联操作同样会带来一些额外的开销，尤其是在大量的输入操作中。</p><p>因此，通过调用 <code>ios::sync_with_stdio(false);</code> 和 <code>cin.tie(0);</code>，可以取消 C++ 输入输出流与 C 的标准 I/O 流的同步，同时取消 cin 和 cout 的关联，从而提高输入输出的效率。这对于竞赛编程等需要高效处理输入输出的场景尤为有用，可以减少不必要的开销，提升程序的执行速度。但需要注意的是，在使用这些优化的同时，可能会导致一些特定的行为变化，如输入输出的顺序可能发生变化，因此在具体应用中需要谨慎使用，并进行充分的测试和验证。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中二分的库函数</title>
      <link href="/2023/10/14/c++%E4%B8%AD%E4%BA%8C%E5%88%86%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/14/c++%E4%B8%AD%E4%BA%8C%E5%88%86%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="c-中二分的库函数"><a href="#c-中二分的库函数" class="headerlink" title="c++中二分的库函数"></a>c++中二分的库函数</h3><p>在 C++ 中，可以使用以下库函数实现二分查找：</p><ol><li><p><code>lower_bound</code>：在有序区间 <code>[first, last)</code> 中查找第一个大于或等于某个值 <code>val</code> 的元素，并返回该元素的迭代器。</p><p>函数原型为 <code>ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; val)</code>，其中 <code>first</code> 和 <code>last</code> 分别表示要查找的区间的起始和终止位置，<code>val</code> 是要查找的值，可以是任意类型。</p><p>例如，查找有序数组 <code>arr</code> 中第一个大于或等于 <code>val</code> 的元素的位置，可以使用以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = <span class="built_in">lower_bound</span>(arr, arr + n, val) - arr;</span><br></pre></td></tr></table></figure><p>其中，<code>n</code> 是数组 <code>arr</code> 的长度，<code>pos</code> 是查找到的元素在数组中的下标。</p></li><li><p><code>upper_bound</code>：在有序区间 <code>[first, last)</code> 中查找第一个大于某个值 <code>val</code> 的元素，并返回该元素的迭代器。</p><p>函数原型为 <code>ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; val)</code>，其中 <code>first</code> 和 <code>last</code> 分别表示要查找的区间的起始和终止位置，<code>val</code> 是要查找的值，可以是任意类型。</p><p>例如，查找有序数组 <code>arr</code> 中第一个大于 <code>val</code> 的元素的位置，可以使用以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = <span class="built_in">upper_bound</span>(arr, arr + n, val) - arr;</span><br></pre></td></tr></table></figure><p>其中，<code>n</code> 是数组 <code>arr</code> 的长度，<code>pos</code> 是查找到的元素在数组中的下标。</p></li></ol><p>需要注意的是，以上两个函数都要求区间 <code>[first, last)</code> 中的元素必须是按照升序排列的。如果区间中的元素没有按照升序排列，结果将是未定义的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中字符串和整型数字相互转换有哪些库函数</title>
      <link href="/2023/10/14/c++%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/14/c++%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，可以使用以下库函数实现字符串和整型数字的相互转换：</p><ol><li><p><code>stoi</code>：将字符串转换为整型数字。函数原型为 <code>int stoi(const string&amp; str, size_t* idx = 0, int base = 10)</code>，其中 <code>str</code> 是要转换的字符串，<code>idx</code> 是可选参数，表示转换过程中第一个非数字字符的位置，<code>base</code> 是可选参数，表示要转换的进制数，默认为十进制。</p></li><li><p><code>to_string</code>：将整型数字转换为字符串。函数原型为 <code>string to_string(int val)</code>，其中 <code>val</code> 是要转换的整型数字。</p></li></ol><p>例如，将字符串 <code>&quot;123&quot;</code> 转换为整型数字，可以使用以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(str);</span><br></pre></td></tr></table></figure><p>将整型数字 <code>123</code> 转换为字符串，可以使用以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(num);</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要转换的字符串或整型数字格式不正确，将会抛出异常。因此，在使用这些库函数时，需要确保输入的字符串或整型数字格式正确。</p><p>比较一下stoi()函数和atoi()函数</p><p>stoi()函数和atoi()函数都是用于字符串和整数之间的转换，但它们有一些不同之处。</p><p>stoi()函数是C++中的标准库函数，它将字符串转换为整数。它的完整形式是std::stoi()，它接受一个字符串作为参数，并尝试将该字符串转换为整数。如果转换成功，它将返回相应的整数值；如果转换失败，它将引发一个std::invalid_argument异常。stoi()函数还可以接受一个可选的基数参数，用于指定字符串中的进制，默认为10进制。例如，stoi(“123”)将返回整数123。</p><p>atoi()函数是C语言中的函数，用于将字符串转换为整数。它的完整形式是atoi()，它接受一个字符串作为参数，并尝试将该字符串转换为整数。如果转换成功，它将返回相应的整数值；如果转换失败，它将返回0。与stoi()函数不同，atoi()函数不提供错误处理机制，因此在转换失败时无法区分失败原因。例如，atoi(“123”)将返回整数123。</p><p>以下是一些stoi()函数和atoi()函数的比较要点：</p><ol><li>错误处理：stoi()函数提供了异常处理机制，可以通过捕获异常来处理转换失败的情况。atoi()函数没有错误处理机制，转换失败时只能返回0。</li><li>转换基数：stoi()函数可以接受一个可选的基数参数，用于指定字符串中的进制。atoi()函数只能处理10进制的字符串。</li><li>类型：stoi()函数返回一个整数值，而atoi()函数返回一个int类型的值。</li></ol><p>总的来说，如果你在使用C++编程，推荐使用stoi()函数，因为它提供了更好的错误处理机制和灵活的进制转换选项。如果你在使用C语言，可以使用atoi()函数，但需要注意它的限制。另外，C++中也可以使用atoi()函数，但它的使用场景相对较少。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++取反操作</title>
      <link href="/2023/10/14/c++%E5%8F%96%E5%8F%8D%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/14/c++%E5%8F%96%E5%8F%8D%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>c++中为什么对5取反等于-6？</p><p>在C++中，对于整数类型，取反操作使用的是补码表示法。对于正整数，取反操作将其二进制表示的每一位取反（0变为1，1变为0），得到其补数的二进制表示。</p><p>然而，这里的结果并不是对于5取反等于-6。对于无符号整数类型，5的二进制表示为 <code>00000101</code>，取反操作后得到 <code>11111010</code>。这个结果是一个大整数，而不是-6。</p><p>但是，如果对于有符号整数类型，5的二进制表示为 <code>00000101</code>，在取反操作时，根据补码表示法，会首先将其转换为补码形式，然后再取反。在补码形式下，5的补码表示为其二进制表示本身 <code>00000101</code>。因此，在取反操作后，得到 <code>11111010</code>，这是一个补码表示的负数。</p><p>如果将 <code>11111010</code> 转换回有符号整数的原码表示，即将最高位的符号位（1）保持不变，其他位取反加1。这样，得到的结果是 <code>-00000110</code>，也就是-6。</p><p>因此，在有符号整数类型中，对于5进行取反操作确实会得到-6，但在无符号整数类型中，取反操作得到的结果不是-6，而是一个大整数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫问题</title>
      <link href="/2023/10/14/%E5%9C%86%E5%9C%88%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97(%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98)/"/>
      <url>/2023/10/14/%E5%9C%86%E5%9C%88%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97(%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98)/</url>
      
        <content type="html"><![CDATA[<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><h5 id="解法一-数组模拟"><a href="#解法一-数组模拟" class="headerlink" title="解法一  数组模拟"></a>解法一  数组模拟</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">bool is_out[100010];</span><br><span class="line">    int lastRemaining(int n, int m)&#123;</span><br><span class="line">int p = n - 1;</span><br><span class="line">for(int i = 0; i &lt; n;  i ++ ) </span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">p = (p + 1) % n;</span><br><span class="line">while(is_out[p])</span><br><span class="line">p = (p + 1) % n;</span><br><span class="line">&#125;</span><br><span class="line">if(i == n - 1) return p;</span><br><span class="line">is_out[p] = 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二 递归"></a>解法二 递归</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastRemaining(int n, int m)&#123;</span><br><span class="line">        if (n == 1) return 0;</span><br><span class="line">        return (lastRemaining(n - 1, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解法三-递推"><a href="#解法三-递推" class="headerlink" title="解法三 递推"></a>解法三 递推</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastRemaining(int n, int m) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; i ++ )</span><br><span class="line">            x = (x + m) % i;   </span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么要引入补码？补码为什么可以把减法转为加法</title>
      <link href="/2023/10/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E8%A1%A5%E7%A0%81/"/>
      <url>/2023/10/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E8%A1%A5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>引入补码的主要原因是简化计算机硬件中的减法操作，使其更加高效和一致。补码的使用具有以下几个优点：</p><ol><li><p>简化电路设计：在计算机中，加法电路通常比减法电路更简单且速度更快。引入补码后，减法操作可以通过将减法问题转化为加法问题来实现，从而减少了需要设计和实现的硬件复杂性。</p></li><li><p>一致性：补码的引入使得减法和加法操作在计算机内部的实现方式更加一致，简化了指令集架构和处理器的设计。这意味着计算机可以使用相同的硬件来执行不同的运算，而不必区分减法和加法。</p></li><li><p>原码和补码的数学性质：补码的定义使得它在数学运算中更加符合直觉。在补码中，减法可以看作是加法的逆操作，这对于编程和算法设计来说更加方便。</p></li></ol><p>补码为什么能够把减法转化为加法呢？这涉及到补码的数学性质。在二进制补码表示中，负数的补码是它的绝对值的二进制表示取反后加1。这意味着减法操作可以简化为加法操作，具体步骤如下：</p><ol><li><p>将减法问题转化为加法问题：要计算A - B，首先需要计算A + (-B)。</p></li><li><p>得到B的补码：为了得到-B的补码，首先将B的绝对值的二进制表示取反，然后加1。</p></li><li><p>执行加法操作：将A和-B的补码相加。</p></li></ol><p>由于补码的性质，这个加法操作会自动处理减法，而且与普通的二进制加法没有区别。这样，计算机内部无需专门的减法电路，简化了硬件设计和实现。因此，补码是计算机中处理有符号整数运算的一种非常有效和方便的表示方式。</p><p>让我重新解释一下：假设我们要计算 5 - 3，并使用8位二进制补码表示法。</p><ol><li><p>首先，将3的绝对值表示为二进制数。3的二进制表示是 0000 0011。</p></li><li><p>接下来，我们需要得到-3的补码。为了得到负数的补码，首先将其绝对值的二进制表示取反，然后加1。所以，-3的补码是 1111 1101。</p></li><li><p>现在，我们将问题转化为加法：5 + (-3)。</p></li><li><p>执行加法操作。在二进制加法中，从最低位（右边）开始，逐位相加。如果有进位，将其传递到下一位。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0000 0101   (5的补码)</span><br><span class="line">+ 1111 1101   (-3的补码)</span><br><span class="line">------------</span><br><span class="line">1 0000 0010</span><br></pre></td></tr></table></figure><p>由于我们采用了8位表示，所以最终结果是一个8位二进制数，但是它的最高位（最左边）溢出了。这个溢出位可以被丢弃，得到最终的计算结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0010</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组去重的代码</title>
      <link href="/2023/10/14/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2023/10/14/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;&amp; nums</span><br><span class="line">nums.erase(unique(nums.begin(), nums.end()), nums.end());</span><br></pre></td></tr></table></figure><p>数组去重的代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>骰子的点数</title>
      <link href="/2023/10/14/%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/"/>
      <url>/2023/10/14/%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>将一个骰子投掷 n 次，获得的总点数为 s，s 的可能范围为 n∼6n。</p><p>掷出某一点数，可能有多种掷法，例如投掷 2 次，掷出 3 点，共有 [1,2],[2,1] 两种掷法。</p><p>请求出投掷 n 次，掷出 n∼6*n 点分别有多少种掷法。</p><p>数据范围   </p><p>1≤n≤10</p><p>暴搜或者动态规划两种做法</p><h5 id="方法一-（暴搜）-O-6-n"><a href="#方法一-（暴搜）-O-6-n" class="headerlink" title="方法一 （暴搜） O(6^n)"></a>方法一 （暴搜） O(6^n)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numberOfDice(int n) &#123;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">for (int i = n; i &lt;= n * 6; i ++ ) res.push_back(dfs(n, i));</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">int dfs(int n, int sum) &#123;</span><br><span class="line">if(sum &lt; 0) return 0;</span><br><span class="line">if(n == 0) return !sum;</span><br><span class="line"></span><br><span class="line">int res = 0;</span><br><span class="line">for(int i = 1; i &lt;= 6; i ++ )</span><br><span class="line">res +=  dfs(n - 1, sum - i);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法二-（记忆化搜索）"><a href="#方法二-（记忆化搜索）" class="headerlink" title="方法二 （记忆化搜索）"></a>方法二 （记忆化搜索）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(int n, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum &lt; 0 || sum &gt; 6 * n) return 0;</span><br><span class="line">        if (n == 0) return !sum;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        if (f[n][sum]) return f[n][sum];</span><br><span class="line">        for (int i = 1; i &lt;= 6; ++i)</span><br><span class="line">            f[n][sum] += dfs(n - 1, sum - i, f);</span><br><span class="line">        return f[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; numberOfDice(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n * 6 + 1));</span><br><span class="line">f[0][0] = 1;</span><br><span class="line">        for (int i = n; i &lt;= 6 * n; ++i)</span><br><span class="line">            res.push_back(dfs(n, i, f));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法三-（动态规划）"><a href="#方法三-（动态规划）" class="headerlink" title="方法三 （动态规划）"></a>方法三 （动态规划）</h5><p>算过的只算一次，不会重复计算，从而把时间复杂度从指数降到多项式级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//f[i][j] : 投了i次，总和为j的方案数</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numberOfDice(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(6 * n + 1, 0));</span><br><span class="line">        f[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">            for (int j = 1; j &lt;= i * 6; j ++ )</span><br><span class="line">                for (int k = 1; k &lt;= 6; k ++ )</span><br><span class="line">                    if (j &gt;= k)</span><br><span class="line">                        f[i][j] += f[i - 1][j - k];</span><br><span class="line">        return vector&lt;int&gt;(f[n].begin() + n, f[n].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序</title>
      <link href="/2023/10/14/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/10/14/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-冒牌排序"><a href="#1-冒牌排序" class="headerlink" title="1.冒牌排序"></a>1.冒牌排序</h3><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ol><p>以下是用 C++ 编写的冒泡排序算法的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) </span><br><span class="line"><span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, size);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><p>以下是用 C++ 编写的选择排序算法的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换 arr[i] 和 arr[minIndex]</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">selectionSort</span>(arr, size);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><p>以下是用 C++ 编写的插入排序算法的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void insertionSort(int arr[], int size) &#123;</span><br><span class="line">    for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">        int key = arr[i];</span><br><span class="line">        int j = i - 1;</span><br><span class="line"></span><br><span class="line">        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[j + 1] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[] = &#123;5, 3, 8, 2, 1, 4&#125;;</span><br><span class="line">    int size = sizeof(arr) / sizeof(arr[0]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;原始数组：&quot;;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    insertionSort(arr, size);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;排序后数组：&quot;;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>筛质数</title>
      <link href="/2023/10/14/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
      <url>/2023/10/14/%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="朴素筛法"><a href="#朴素筛法" class="headerlink" title="朴素筛法"></a>朴素筛法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N= <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么加引用比不加引用快一些</title>
      <link href="/2023/10/14/%E5%8A%A0%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%8D%E5%8A%A0%E5%BC%95%E7%94%A8/"/>
      <url>/2023/10/14/%E5%8A%A0%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%8D%E5%8A%A0%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么加引用比不加引用快一些"><a href="#为什么加引用比不加引用快一些" class="headerlink" title="为什么加引用比不加引用快一些"></a>为什么加引用比不加引用快一些</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> value : strs)&#123;</span><br><span class="line">string key = value;</span><br><span class="line"><span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">hash[key].<span class="built_in">push_back</span>(value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; value : strs)&#123;</span><br><span class="line">string key = value;</span><br><span class="line"><span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">hash[key].<span class="built_in">push_back</span>(<span class="built_in">move</span>(value)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个代码中，循环变量 value 是按值传递的，也就是说每次循环都会创建一个字符串的拷贝，然后再对拷贝进行操作。这样做会造成额外的内存开销和时间消耗，尤其是当字符串比较长的时候。</p><p>在第二个代码中，循环变量 value 是按引用传递的，也就是说每次循环都会使用原始字符串，而不是创建拷贝。这样做可以减少内存开销和时间消耗，因为不需要为每个字符串都创建一份拷贝。</p><p>此外，第二个代码中使用了 std::move() 函数，将原始字符串的所有权转移给哈希表中的元素，避免了多余的拷贝操作，提高了效率。</p><p>因此，在循环中使用引用比不使用引用更快一些，尤其是当处理大量字符串时。</p><p>问 ： 为什么这里  <code>void dfs(string&amp; s, int u)</code>  要用引用，什么时候用引用，什么时候不用呢</p><p>在这个函数中，使用 <code>string&amp;</code> 类型的引用是为了避免复制字符串 <code>s</code>，从而减少空间开销和时间消耗。如果不使用引用，而是直接传递 <code>string</code> 类型的参数，那么在每次递归调用时都需要复制一份字符串，这样会增加空间开销和时间消耗。</p><p>一般来说，如果函数需要修改参数的值或者需要访问参数的引用，就需要使用引用类型作为函数参数；如果函数不需要修改参数的值，也不需要访问参数的引用，就可以使用值类型作为函数参数。但是需要注意，如果参数是一个大型的对象或者容器，而函数只需要访问其中的一部分元素，那么使用引用类型可以避免复制整个对象或容器，从而提高程序的效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>括号问题</title>
      <link href="/2023/10/14/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
      <url>/2023/10/14/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>20 :判断字符串括号是否有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">stack&lt;char&gt; stk;</span><br><span class="line"></span><br><span class="line">bool check(char a, char b)&#123;</span><br><span class="line">if(a == &#x27;)&#x27; &amp;&amp; b == &#x27;(&#x27;) return true;</span><br><span class="line">if(a == &#x27;]&#x27; &amp;&amp; b == &#x27;[&#x27;) return true;</span><br><span class="line">if(a == &#x27;&#125;&#x27; &amp;&amp; b == &#x27;&#123;&#x27;) return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">for(int i = 0; i &lt; s.size(); i ++ )&#123;</span><br><span class="line">if(s[i] == &#x27;(&#x27; || s[i] == &#x27;&#123;&#x27; || s[i] == &#x27;[&#x27;) stk.push(s[i]);</span><br><span class="line">else&#123;</span><br><span class="line">if(stk.size() &amp;&amp; check(s[i], stk.top())) stk.pop();</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(stk.empty()) return true;</span><br><span class="line">else return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>22:括号生成</p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>结论： </p><p>一个合法的括号序列需要满足以下两个条件：</p><ol><li>任意前缀中左括号的数量 ≥ 右括号的数量；</li><li>左右括号数量相等。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">dfs(n, 0, 0, &quot;&quot;);</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(int n, int lc, int rc, string seq)&#123;</span><br><span class="line">if(lc == n &amp;&amp; rc == n)&#123;</span><br><span class="line">res.push_back(seq);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(lc &lt; n) dfs(n, lc + 1, rc, seq + &#x27;(&#x27;);</span><br><span class="line">if(rc &lt; n &amp;&amp; lc &gt; rc) dfs(n, lc, rc + 1, seq + &#x27;)&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>32：最长有效括号</p><p>```</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>和为S的连续正数序列</title>
      <link href="/2023/10/14/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2023/10/14/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= target &lt;= 10^5</span><br></pre></td></tr></table></figure><h5 id="方法一-暴力"><a href="#方法一-暴力" class="headerlink" title="方法一 暴力"></a>方法一 暴力</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//和为s的连续正数序列</span><br><span class="line">//O(n^2)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">for(int i = 1; i &lt; target; i ++) &#123;</span><br><span class="line">for(int j = i + 1; j &lt; target; j ++ ) &#123;</span><br><span class="line">int s = (i + j) * (j - i + 1) / 2;</span><br><span class="line">if(s &gt; target) break;</span><br><span class="line">if(s == target) &#123;</span><br><span class="line">vector&lt;int&gt; tmp;</span><br><span class="line">for(int k = i; k &lt;= j; k ++ )</span><br><span class="line">tmp.push_back(k);</span><br><span class="line">res.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法二-二分"><a href="#方法二-二分" class="headerlink" title="方法二  二分"></a>方法二  二分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//二分 O(nlogn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">for(int i = 1; i &lt; target; i ++) &#123;</span><br><span class="line">int l = i + 1, r = target;</span><br><span class="line">while(l &lt; r) &#123;</span><br><span class="line">int mid = l + r &gt;&gt; 1;</span><br><span class="line">long long s = (i + mid) * 1LL * (mid - i + 1) / 2;</span><br><span class="line">if(s &lt; target) l = mid + 1;</span><br><span class="line">else r = mid;</span><br><span class="line">&#125;</span><br><span class="line">int s = (i + r) * (r - i + 1) / 2;</span><br><span class="line">if(s == target) &#123;</span><br><span class="line">vector&lt;int&gt; tmp;</span><br><span class="line">for(int k = i; k &lt;= r; k ++ )</span><br><span class="line">tmp.push_back(k);</span><br><span class="line">res.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于lowbit()</title>
      <link href="/2023/10/14/%E5%85%B3%E4%BA%8Elowbit/"/>
      <url>/2023/10/14/%E5%85%B3%E4%BA%8Elowbit/</url>
      
        <content type="html"><![CDATA[<p>为什么将 n 取反加一，会得到得到 -n?</p><p>当一个数 <code>n</code> 的二进制表示为正数时，其取反加一的结果为其负数的二进制表示。这是因为负数在计算机中使用补码表示。</p><p>在计算机中，负数常用补码表示法来表示，其中一个数的补码等于其反码加一。反码是将该数的二进制表示中的0和1互换得到的结果。取反加一的操作正是将一个数的二进制表示取反，然后再加一。</p><p>具体来说，对于一个非负整数 <code>n</code>，其二进制表示为 <code>b_0 b_1 b_2 ... b_k</code>，其中 <code>b_i</code> 表示二进制表示的第 <code>i</code> 位。</p><p>取反操作将 <code>b_i</code> 中的 0 变为 1，1 变为 0，得到 <code>~b_0 ~b_1 ~b_2 ... ~b_k</code>。 加一操作将 <code>~b_i</code> 中的最低有效位（即最右边的位）进位，得到 <code>~b_0 ~b_1 ~b_2 ... ~b_k + 1</code>。</p><p>由于负数采用补码表示，因此 <code>~b_0 ~b_1 ~b_2 ... ~b_k + 1</code> 的结果就是 <code>n</code> 的负数表示。因此，当 <code>n</code> 是正数时，取反加一的结果就是其对应的负数。</p><p>例如，对于整数 <code>n = 12</code>，其二进制表示为 <code>1100</code>。取反操作得到 <code>0011</code>，再加一得到 <code>0100</code>，即二进制表示为 <code>-4</code>。</p><p>这种补码表示法使得计算机可以使用相同的电路来处理正数和负数，简化了硬件的设计和运算的实现。同时，补码还满足了一些运算规则，如加法、减法等，使得整数运算能够在计算机中得到正确的结果。</p><p><code> lowbit(n)</code></p><p><code>lowbit(n)</code> 是一个常见的位运算操作，用于计算一个非负整数 <code>n</code> 的最低有效位（Lowest Set Bit）。</p><p>最低有效位是指一个数在二进制表示中最右边的、值为 1 的位。对于一个非负整数 <code>n</code>，<code>lowbit(n)</code> 的结果就是 <code>n</code> 的二进制表示中最右边的 1 所在的位所代表的值。</p><p>具体而言，<code>lowbit(n)</code> 可以通过以下方式计算：</p><ol><li>将 <code>n</code> 取反加一，得到 <code>-n</code>。</li><li><code>n</code> 和 <code>-n</code> 进行按位与操作（<code>n &amp; (-n)</code>）。</li><li>得到的结果即为 <code>n</code> 的最低有效位所代表的值。</li></ol><p>例如，对于整数 <code>n = 12</code>，其二进制表示为 <code>1100</code>，最低有效位对应的是最右边的位，其值为 4。因此，<code>lowbit(12)</code> 的结果为 4。</p><p><code>lowbit(n)</code> 在编程中常用于位运算和优化算法中，可以用于判断一个数是否为 2 的幂次方、统计二进制中 1 的个数等操作。它的计算效率非常高，常用于需要高效处理位操作的场景。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2023/10/14/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2023/10/14/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><h3 id="一-高精度加法"><a href="#一-高精度加法" class="headerlink" title="一. 高精度加法"></a>一. 高精度加法</h3><p>给定两个正整数（不含前导 00），计算它们的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤100000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    if (A.size() &lt; B.size()) return add(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t = 0;</span><br><span class="line">    for (int i = 0; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        if (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % 10);</span><br><span class="line">        t /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (t) C.push_back(t);</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;int&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;);</span><br><span class="line">    for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">    auto C = add(A, B);</span><br><span class="line"></span><br><span class="line">    for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-高精度减法"><a href="#二-高精度减法" class="headerlink" title="二. 高精度减法"></a>二. 高精度减法</h3><p>给定两个正整数（不含前导 00），计算它们的差，计算结果可能为负数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的差。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤105</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    if (A.size() != B.size()) return A.size() &gt; B.size();</span><br><span class="line"></span><br><span class="line">    for (int i = A.size() - 1; i &gt;= 0; i -- )</span><br><span class="line">        if (A[i] != B[i])</span><br><span class="line">            return A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    for (int i = 0, t = 0; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        if (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + 10) % 10);</span><br><span class="line">        if (t &lt; 0) t = 1;</span><br><span class="line">        else t = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;int&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;);</span><br><span class="line">    for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    if (cmp(A, B)) C = sub(A, B);</span><br><span class="line">    else C = sub(B, A), cout &lt;&lt; &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">    for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-高精度乘法"><a href="#三-高精度乘法" class="headerlink" title="三. 高精度乘法"></a>三. 高精度乘法</h3><p>给定两个非负整数（不含前导 00） A 和 B，请你计算 A×B 的值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 A，第二行包含整数 B。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 A×B 的值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤A的长度≤100000<br>0≤B≤10000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t = 0;</span><br><span class="line">    for (int i = 0; i &lt; A.size() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % 10);</span><br><span class="line">        t /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();</span><br><span class="line"></span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a;</span><br><span class="line">    int b;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; A;</span><br><span class="line">    for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">    auto C = mul(A, b);</span><br><span class="line"></span><br><span class="line">    for (int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-高精度除法"><a href="#四-高精度除法" class="headerlink" title="四. 高精度除法"></a>四. 高精度除法</h3><p>给定两个非负整数（不含前导 00） A，B，请你计算 A/B的商和余数。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 A，第二行包含整数 B。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤A的长度≤100000<br>1≤B≤10000<br>B 一定不为 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    r = 0;</span><br><span class="line">    for (int i = A.size() - 1; i &gt;= 0; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * 10 + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a;</span><br><span class="line">    vector&lt;int&gt; A;</span><br><span class="line"></span><br><span class="line">    int B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; B;</span><br><span class="line">    for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">    int r;</span><br><span class="line">    auto C = div(A, B, r);</span><br><span class="line"></span><br><span class="line">    for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附，高精度-高精度"><a href="#附，高精度-高精度" class="headerlink" title="附，高精度 * 高精度"></a>附，高精度 * 高精度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123;</span><br><span class="line">    vector&lt;int&gt; C(A.size() + B.size() + 7, 0); // 初始化为 0，C的size可以大一点</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; A.size(); i++)</span><br><span class="line">        for (int j = 0; j &lt; B.size(); j++)</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line"></span><br><span class="line">    int t = 0;</span><br><span class="line">    for (int i = 0; i &lt; C.size(); i++) &#123; // i = C.size() - 1时 t 一定小于 10</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % 10;</span><br><span class="line">        t /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; // a = &quot;1222323&quot;, b = &quot;2323423423&quot;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; A, B;</span><br><span class="line">    for (int i = a.size() - 1; i &gt;= 0; i--)</span><br><span class="line">        A.push_back(a[i] - &#x27;0&#x27;);</span><br><span class="line">    for (int i = b.size() - 1; i &gt;= 0; i--)</span><br><span class="line">        B.push_back(b[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">    auto C = mul(A, B);</span><br><span class="line"></span><br><span class="line">    for (int i = C.size() - 1; i &gt;= 0; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>非静态成员函数</title>
      <link href="/2023/10/14/%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/14/%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>剑指45</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    bool cmp(string&amp; a, string&amp; b) &#123;</span><br><span class="line">        return a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string minNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;string&gt; nums_s;</span><br><span class="line">        for(auto c : nums) </span><br><span class="line">            nums_s.push_back(to_string(c));</span><br><span class="line"></span><br><span class="line">        // 创建 Solution 类的实例</span><br><span class="line">        Solution sol;</span><br><span class="line"></span><br><span class="line">        // 使用实例调用非静态成员函数 cmp</span><br><span class="line">        sort(nums_s.begin(), nums_s.end(), [sol](string&amp; a, string&amp; b) &#123;</span><br><span class="line">            return sol.cmp(a, b);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for(auto&amp; c : nums_s)</span><br><span class="line">            res += c;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference to non-static member function must be called</span><br><span class="line">                sort(nums_s.begin(), nums_s.end(), cmp);</span><br></pre></td></tr></table></figure><p>你遇到的错误 “reference to non-static member function must be called” 表示你在使用非静态成员函数作为排序函数时，未正确调用这个成员函数。在C++中，非静态成员函数需要一个实例来调用，因此在传递非静态成员函数给 <code>std::sort</code> 进行排序时，必须使用类的实例来调用该函数。</p><h4 id="静态成员函数和非静态成员函数的区别"><a href="#静态成员函数和非静态成员函数的区别" class="headerlink" title="静态成员函数和非静态成员函数的区别"></a>静态成员函数和非静态成员函数的区别</h4><p>静态成员函数和非静态成员函数都是类的成员函数，但它们有以下区别：</p><ol><li><p>调用方式：</p><ul><li>静态成员函数可以通过类名直接调用，无需创建类的实例。例如，<code>ClassName::staticFunction()</code>。</li><li>非静态成员函数需要通过类的实例来调用。例如，<code>ClassName obj; obj.nonStaticFunction()</code>。</li></ul></li><li><p>访问权限：</p><ul><li>静态成员函数可以访问类的静态成员（包括静态变量和其他静态函数），但不能访问非静态成员。</li><li>非静态成员函数可以访问类的静态成员和非静态成员。</li></ul></li><li><p>隐含的 this 指针：</p><ul><li>静态成员函数没有隐含的 <code>this</code> 指针，因为它不依赖于类的实例。</li><li>非静态成员函数有一个隐含的 <code>this</code> 指针，它指向调用该函数的类的实例，使函数能够访问该实例的成员变量和其他成员函数。</li></ul></li><li><p>存储方式：</p><ul><li>静态成员函数不依赖于类的实例，因此它们通常用于执行与类相关但与特定实例无关的操作。静态函数只有一份副本，不与任何特定对象相关联。</li><li>非静态成员函数与类的每个实例相关联，每个实例都有一份独立的成员函数副本。</li></ul></li><li><p>生命周期：</p><ul><li>静态成员函数的生命周期与程序的生命周期相同，与类的实例化和销毁无关。</li><li>非静态成员函数的生命周期与所属对象的生命周期相同。</li></ul></li></ol><p>总之，静态成员函数通常用于类的全局操作或工具函数，而非静态成员函数用于操作特定类的实例数据。你可以根据具体的需求选择使用哪种类型的成员函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>参数前加const</title>
      <link href="/2023/10/14/%E5%8F%82%E6%95%B0%E5%89%8D%E5%8A%A0const/"/>
      <url>/2023/10/14/%E5%8F%82%E6%95%B0%E5%89%8D%E5%8A%A0const/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">const</span> <span class="type">int</span> target,<span class="type">int</span> u)</span></span></span><br></pre></td></tr></table></figure><p>函数参数前面加const表示什么</p><p>在 C++ 中，<code>const</code> 关键字用于修饰变量或函数参数，表示它们的值不能被修改。在这个函数中，<code>const</code> 关键字修饰了函数参数 <code>candidates</code>，表示它是一个只读的向量，不能被修改。这样做的目的是为了避免在函数中意外修改了向量 <code>candidates</code> 的值，导致程序出错。</p><p>使用 <code>const</code> 关键字可以提高程序的可读性和可维护性，因为它可以帮助开发人员更好地理解代码的意图，并避免意外的错误。特别是在大型项目中，使用 <code>const</code> 关键字可以帮助开发人员更好地组织代码，减少代码的错误和维护成本。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反转整数</title>
      <link href="/2023/10/14/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2023/10/14/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>可以使用以下步骤将一个整型数据 <code>n</code> 反转：</p><ol><li>初始化一个变量 <code>rev</code> 为 0，用于存储反转后的结果。</li><li>循环将 <code>n</code> 的末位数字取出来，加入到 <code>rev</code> 中，并将 <code>n</code> 除以 10。</li><li>当 <code>n</code> 为 0 时，循环结束，此时 <code>rev</code> 中存储的就是 <code>n</code> 反转后的结果。</li></ol><p>以下是使用 C++ 实现将一个整型数据反转的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sign = n &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;  <span class="comment">// 记录符号</span></span><br><span class="line">    n = <span class="built_in">abs</span>(n);  <span class="comment">// 转换为正数</span></span><br><span class="line">    <span class="type">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> digit = n % <span class="number">10</span>;  <span class="comment">// 取出末位数字</span></span><br><span class="line">        rev = rev * <span class="number">10</span> + digit;  <span class="comment">// 加入到 rev 中</span></span><br><span class="line">        n /= <span class="number">10</span>;  <span class="comment">// 将 n 除以 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign * rev;  <span class="comment">// 加上符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2023/10/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/10/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h5 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line">int n, m;</span><br><span class="line">    </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">     </span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        for(int j = 0; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = f[i - 1][j];</span><br><span class="line">                if(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化成一维</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N];</span><br><span class="line">int n, m;</span><br><span class="line">    </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i ++ )  </span><br><span class="line">        for(int j = m; j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];        </span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\project\notes\image-20230617195854334.png" alt="image-20230617195854334"></p><p>优化成一维</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N];</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        for(int j = v[i]; j &lt;= m; j++)</span><br><span class="line">            f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>string中的find</title>
      <link href="/2023/10/14/string%E4%B8%AD%E7%9A%84find/"/>
      <url>/2023/10/14/string%E4%B8%AD%E7%9A%84find/</url>
      
        <content type="html"><![CDATA[<p><code>std::string::find</code> 是 C++ 标准库中的一个成员函数，用于在 <code>std::string</code> 类型的字符串对象中查找特定子字符串，并返回第一次出现该子字符串的位置。这个函数非常有用，因为它允许你在字符串中搜索并定位子字符串，从而执行各种字符串操作。</p><p><code>std::string::find</code> 的一般语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>str</code> 是你要搜索的目标子字符串。</li><li><code>pos</code> 是可选参数，表示搜索的起始位置。默认值为 0，从字符串的开头开始搜索。</li></ul><p>返回值是一个 <code>size_t</code> 类型的整数，表示子字符串在原始字符串中的位置。如果找不到子字符串，则返回 <code>std::string::npos</code>，它是一个常量，通常被定义为 <code>size_t</code> 类型的最大值。</p><p>以下是一个示例用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::string target = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> found = text.<span class="built_in">find</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Target found at position &quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Target not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>find</code> 函数搜索字符串 <code>target</code> 在 <code>text</code> 中的位置，如果找到，则返回第一次出现的位置，否则返回 <code>std::string::npos</code>。</p><p>你还可以使用其他重载版本的 <code>std::string::find</code> 来进行更复杂的字符串搜索，例如指定搜索范围或使用自定义的比较函数。这使得它成为一个功能强大且灵活的字符串查找工具。</p><p><code>size_t</code> 是 C/C++ 编程语言中常见的数据类型之一，通常用于表示对象的大小或数组的索引。它是一个无符号整数类型，其大小在不同系统中可能会有所不同，但它的主要目的是在内存中表示大小或位置的非负整数值。</p><p>以下是关于 <code>size_t</code> 的一些重要特点和用途：</p><ol><li><p>无符号整数：<code>size_t</code> 是一个无符号整数类型，因此它只能表示非负整数值。这意味着它不能表示负数。</p></li><li><p>平台相关：<code>size_t</code> 的大小（即所占字节数）在不同的编译器和操作系统下可能会有所不同。通常情况下，它被定义为足够大以容纳目标平台上最大可能的对象大小。</p></li><li><p>表示容器大小：<code>size_t</code> 常用于表示容器（如数组、向量、字符串等）的大小或元素的数量。例如，你可以使用 <code>size_t</code> 来获取数组的长度或字符串中字符的数量。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"><span class="type">size_t</span> size = numbers.<span class="built_in">size</span>(); <span class="comment">// 获取向量中元素的数量</span></span><br></pre></td></tr></table></figure><ol start="4"><li>循环索引：<code>size_t</code> 通常用于循环中，作为数组或容器的索引，以便访问其中的元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 使用 size_t 作为索引访问向量中的元素</span></span><br><span class="line">    <span class="type">int</span> value = numbers[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>内存分配：<code>size_t</code> 也经常用于与内存分配和管理相关的操作，例如 <code>malloc</code> 或 <code>new</code> 函数的参数，以指定要分配的内存块的大小。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>); <span class="comment">// 分配足够大的内存块以容纳10个整数</span></span><br></pre></td></tr></table></figure><p>总之，<code>size_t</code> 是一个用于表示大小、容器元素数量和内存分配的无符号整数类型，它在 C/C++ 编程中具有广泛的应用。要注意，由于它是无符号类型，应确保在使用时避免出现溢出或与带符号整数类型混合使用时的问题。</p><p><code>std::string::npos</code> 是 <code>std::string</code> 类中的一个静态成员，通常被定义为一个特殊的常量值，表示字符串中某些操作的无效或错误结果。尽管在概念上它表示一个无效的位置或索引，但它实际上是一个特定于实现的无符号整数值。因此，尝试将其与负数值进行比较或替代可能导致问题，因为无符号整数与带符号整数有不同的性质。</p><p>通常，<code>std::string::npos</code> 的值被设置为足够大以保证它可以表示字符串中的任何位置，因此它通常是一个大的正整数值，而不是负数。因此，将其与 -1 相等的想法可能会导致不一致或错误的结果，因为 -1 是一个带符号整数，而 <code>std::string::npos</code> 是无符号整数。</p><p>要正确比较或替代 <code>std::string::npos</code>，你应该使用无符号整数类型，而不是负数值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">    <span class="comment">// 找到了子字符串</span></span><br><span class="line">    <span class="comment">// 在这里执行相关操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未找到子字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::string::npos</code> 与无符号整数值进行比较是一种良好的编程实践，可以确保代码的可移植性和正确性，因为它与底层数据类型的细节无关。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>static的作用</title>
      <link href="/2023/10/14/static%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/10/14/static%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这个函数上面要加static</p><p>这个函数上面加 <code>static</code> 是为了限定其作用域，使其只在当前文件中生效，避免与其他文件中的同名函数产生冲突。</p><p>在 C++ 中，<code>static</code> 关键字可以用于函数和变量上。对于函数来说，<code>static</code> 的作用是将函数的作用域限定在当前文件中，使其只在当前文件中可见。也就是说，其他文件中的同名函数不会与其产生冲突，避免了命名空间的问题。</p><p>在这个例子中，<code>static</code> 关键字将 <code>cmp</code> 函数的作用域限定在当前文件中，避免了与其他文件中的同名函数产生冲突。这在大型项目中尤为重要，因为大型项目中通常包含很多文件，如果不限定函数的作用域，同名函数可能会在不同文件中产生冲突，导致编译错误。</p><p>除了限定函数作用域之外，<code>static</code> 还可以用于变量上，用于将变量的作用域限定在当前文件中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LIS问题解法</title>
      <link href="/2023/10/14/LIS/"/>
      <url>/2023/10/14/LIS/</url>
      
        <content type="html"><![CDATA[<p>LIS</p><p>解法一</p><pre><code class="highlight c++"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;<span class="type">int</span> a[N], f[N];<span class="type">int</span> n;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )    &#123;        f[i] = <span class="number">1</span>;        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt; i; k ++ )            <span class="keyword">if</span>(a[k] &lt; a[i])                f[i] = <span class="built_in">max</span>(f[i], f[k] + <span class="number">1</span>);    &#125;        <span class="type">int</span> res = <span class="number">0</span>;    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )        res = <span class="built_in">max</span>(res, f[i]);        cout &lt;&lt; res;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>解法二</p><pre><code class="highlight plaintext">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N];int q[N];int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);    int len = 0;    for (int i = 0; i &lt; n; i ++ )    &#123;        int l = 0, r = len;        while (l &lt; r)        &#123;            int mid = l + r + 1 &gt;&gt; 1;            if (q[mid] &lt; a[i]) l = mid;            else r = mid - 1;        &#125;        len = max(len, r + 1);        q[r + 1] = a[i];    &#125;    printf(&quot;%d\n&quot;, len);    return 0;&#125;//LIS#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int a[N], f[N];int n; int main()&#123;    cin &gt;&gt; n;        for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);    f[1] = a[1];    int j = 1;    for(int i = 2; i &lt;= n; i ++ )        if(a[i] &gt; f[j])            f[ ++ j] = a[i];        else            *lower_bound(f + 1, f + 1 + j, a[i]) = a[i];                        cout &lt;&lt; j &lt;&lt; endl;    return 0;&#125;</code></pre><p>拦截导弹</p><pre><code class="highlight plaintext">#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;int h[N], f[N], q[N];int main()&#123;    string line;    getline(cin, line);    stringstream ssin(line);    while (ssin &gt;&gt; h[n]) n ++ ;    int res = 0, cnt = 0;    for (int i = 0; i &lt; n; i ++ )    &#123;        f[i] = 1;        for (int j = 0; j &lt; i; j ++ )            if (h[i] &lt;= h[j])                f[i] = max(f[i], f[j] + 1);        res = max(res, f[i]);        int k = 0;        while (k &lt; cnt &amp;&amp; q[k] &lt; h[i]) k ++ ;        if (k == cnt) q[cnt ++ ] = h[i];        else q[k] = h[i];    &#125;    printf(&quot;%d\n&quot;, res);    printf(&quot;%d\n&quot;, cnt);    return 0;&#125;</code></pre><pre><code class="highlight plaintext">int main()&#123;    while(cin &gt;&gt; a[n]) n ++;    int ans = 0, cnt = 0;    for(int i = 0; i &lt; n; i ++)    &#123;        f[i] = 1;        for(int j = 0; j &lt; i; j ++)        &#123;            if(a[i] &lt;= a[j]) f[i] = max(f[i], f[j] + 1);        &#125;        ans = max(ans, f[i]);        //数组g的每个元素代表一套导弹拦截系统的拦截序列        //g[i]表示此时第i套导弹拦截系统所拦截的最后一个导弹的高度        int p = lower_bound(g, g+cnt, a[i]) - g;        if(p == cnt) g[cnt ++] = a[i];  //a[i]开创一套新拦截系统            else g[p] = a[i];               //a[i]成为第p套拦截系统最后一个导弹高度    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;&#125;</code></pre><pre><code class="highlight plaintext">int main()&#123;    //cnt表示导弹系统数，len表示一个系统最多能拦截的导弹数    int len = 0, cnt = 0;    int a;    while(cin &gt;&gt; a)    &#123;        //pos1表示以a结尾的最长不升子序列长度        int pos1 = upper_bound(f, f+len, a, greater&lt;int&gt;()) - f;        if(pos1 == len) f[len ++] = a;        else f[pos1] = a;        int pos2 = lower_bound(g, g+cnt, a[i]) - g;        if(pos2 == cnt) g[cnt ++] = a;        else g[pos2] = a;    &#125;    cout &lt;&lt; len &lt;&lt; endl;    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lc208中函数的定义方式</title>
      <link href="/2023/10/14/lc208%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/10/14/lc208%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="对象和指针的定义方式"><a href="#对象和指针的定义方式" class="headerlink" title="对象和指针的定义方式"></a>对象和指针的定义方式</h5><p>下面这两种定义方式有什么区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">        bool is_end;</span><br><span class="line">        Node *son[26];</span><br><span class="line">        Node() &#123;</span><br><span class="line">            is_end = false;</span><br><span class="line">            for (int i = 0; i &lt; 26; i ++ )</span><br><span class="line">                son[i] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*root;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">        bool is_end;</span><br><span class="line">        Node *son[26];</span><br><span class="line">        Node() &#123;</span><br><span class="line">            is_end = false;</span><br><span class="line">            for (int i = 0; i &lt; 26; i ++ )</span><br><span class="line">                son[i] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;root;</span><br></pre></td></tr></table></figure><p>这两种定义方式的区别在于根结点的类型不同。</p><p>第一种方式定义的根结点是一个指向 Node 类型的指针，即 root 是一个指针变量，指向一个 Node 类型的对象。我们可以通过 root 指针来访问 Trie 树的所有结点，也可以通过 new 运算符动态分配内存来创建 Trie 树。</p><p>第二种方式定义的根结点是一个 Node 类型的对象，即 root 是一个对象变量。我们可以直接访问 root 对象来访问 Trie 树的所有结点，也可以通过将 root 传递给函数来操作 Trie 树。</p><p>需要注意的是，这两种定义方式的根结点都是在栈上分配内存，因此其作用域只限于定义它们的代码块。如果需要在函数之间共享根结点，应该使用第一种方式，并且需要注意释放内存。</p><h3 id="在算法题中，使用数组模拟-Trie-树的效率更高，主要有以下几个原因："><a href="#在算法题中，使用数组模拟-Trie-树的效率更高，主要有以下几个原因：" class="headerlink" title="在算法题中，使用数组模拟 Trie 树的效率更高，主要有以下几个原因："></a>在算法题中，使用数组模拟 Trie 树的效率更高，主要有以下几个原因：</h3><ol><li>数组访问速度更快。在数组中，每个元素的地址都可以通过下标计算得到，因此访问数组的速度非常快。而使用 new 运算符创建结点，则需要动态分配内存，访问速度相对较慢。</li><li>数组占用的内存更少。使用 new 运算符创建结点需要分配额外的内存空间，而使用数组模拟 Trie 树则只需要一个固定大小的数组即可</li><li>数组实现更简单。使用数组实现 Trie 树的代码更加简洁明了，容易理解和实现。</li></ol><p>因此，在算法题中，如果对空间要求不是非常苛刻，建议使用数组模拟 Trie 树，可以提高程序的效率和可读性</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
